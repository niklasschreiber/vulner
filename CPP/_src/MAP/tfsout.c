//--------------------------------------------------------------------------------
//   PROJECT : Traffic Steering - Outbound Server - v 1.11
//--------------------------------------------------------------------------------
//
//   File Name   : tfsout.c
//
//   Created     : 01-09-2004
//
//   Last fix	 : 29-11-2004
//                 15-04-2004 Add TCAP_END / TCAP-CONTINUE management: to do relay
//                 07-09-2005 Add EVT manage
//				   25-11-2005 Add VLR CC and MGT external parameters
//				   13-01-2006 Add memory list of VLR GT
//				   03-03-2006 Link with FRAMEWORK $dsmscm.fwaobj
//				   10-04-2006 CPU Request sending request to GTT and TFS Manager
//				   23-05-2007 TCAP-ABORT managed
//							  fixed bug: break in the switch
//				   02-10-2008 Added GT originator control for GPRS Location Update
//				   15-10-2008 Link with FRAMEWORK C and code optimizing
//				   15-02-2010 Added statistic counters idx 89,90,91 and 92
//				   10-06-2010 Bug fix allow VPC
//				   15-03-2011 Added new field c_tcap_map_errorcode into gtt and ts IPC structures
//				   22-03-2011 Added other MAP Error management
//				   01-07-2011 Recompiled for KTSTEA07
//				   28-06-2012 Deployed KTSTEACE ( to be include in KTSTEA08 )
//								- optimized input parameters
//								- Added SSN configuration
//				   30-08-2012 Managed MGT len greater than 16  ( routing SCCP max len 32 - MGT max len 30 )
//							  Relaying msg, internal routing managed: Changes to stop checking if the local point code is available, to overcome erroneous retcode from L_SS7_PC_STATUS
//				   04-09-2012 Added IMSI into ts IPC struct
//				   20-09-2012 Bug Fixed EVT_MANAGER - Fixed the maximum number of events generated by TFS MAP i/f
//													  in a given period of time in order to respect the value
// 													  configured as NBR-ALERT-MSG and/or INTERVAL-ALERT-MSG-TIME parameters
//				   28-11-2012 Bug  Fix: The frames TCAP-CONTINUE,ABORT and END are relayed correctly by RELAY-SERVER
//										necessary to manage the wrong traffic coming from national core network
//				   19-12-2012 Recompiled for A08.01
//				   31-05-2013 Recompiled for A08.02 - due to adding of LTE i/f
//				   10-09-2013 Bug Fixed 3987: - SCCP Calling Party Address Digits Number with length equal to zero
//											  - UDTS Header Decoding Information:
//													the decoding of UDTS messages with Return Cause field
//													size longer than 50 bytes generated a stack overflow
//				   13-09-2013 Recompiled for A08.02 it has been included the bug fix KTSTEACR
//				   02-07-2014 RVU 09.00
//							   - Added Roaming Unbundling management
//				   			   - Added Dual IMSI management: Relaying of LU GSM/GPRS
//								 with Routing Indicator - routing on GT
//				   14-10-2014 Added check MTP3 DPC availability on relaying message towards MAP Pxy or HLR
//				   17-11-2014 Bug Fix 4241 - statistics counters 93/94 for MAP-Pxy - KTSTEACZ
//				   21-11-2014 Bug Fix 4242 - TFS Outbound server did not start if the ARP profile dbase was empty - KTSTEADA
//				   13-04-2015 KTSTEADD - Added anti steering management for LU GSm/GPrs with SCCP CdPA NPI E.164(GT) instead of E.214 (MGT)
//				   18-11-2015 KTSTEADH - Bug fixing wrong invoke id returned towards vlr/sgsn for steering case
//				   23-03-2016 KTSTEADK - Bug fix ErrCmp SystemFailure Network Resource MAP V3
//				   15-05-2017 KTSTEADQ - HLR on DLA(Down Low Adjust) architecture, FAI(Flexible Allocation of IMSI) activation
//				   18-12-2017 KTSTEADT - Steering with RoamingNotAllowed error and cause plmnRoamingNotAllowed = 0 instead of operatorDeterminedBarring = 3
//				   29-03-2018 KTSTEADV - Flexible Allocation of IMSI (FAI) - Management of GSM LU/GPRS LU and SCCP CdPA ITU E.164
//
//---------------------------------------------------------------------------------
//
//	Last change  : 29-03-2018
//
//---------------------------------------------------------------------------------
//   Description
//   -----------
//
//---------------------------------------------------------------------------------
//   Functions
//   ------------------
//---------------------------------------------------------------------------------
//---------------------< Include files >-------------------------------------------
#pragma nolist
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <time.h>
#include <ctype.h>
#include <tal.h>
#include <unistd.h>
#include <p2system.p2apdfh>
#include <erainc.ccpy>
#include <cssinc.cext>
#include <cextdecs.h (DELAY,PROCESSHANDLE_GETMINE_,PROCESSHANDLE_DECOMPOSE_,JULIANTIMESTAMP)>
#include <usrlib.h>
#include <fwlbdf.h>
#include <fwroute.h>
#include <fwdef.h>
#include <fwutlx.h>
#include <fwstatl.h>
#include <sspevt.h>
#include <ssplog.h>
#include <sspfunc.h>
#include <sspstat.h>
#include "tfsout.h"
#include "tfsipc.h"
#include "tfsfunc.h"
#include "tfsdef.h"
#include "tfsdb.h"
#include "arpdb.h"
#include "ipcfunc.h"
#include "gsmdef.h"
#include "tfsevt.h"
#include "tfsstat.h"
#pragma list

//---------------------< Definitions >-----------------------------------------

#if (_TNS_E_TARGET)
T0000H06_21JUN2018_KTSTEA10_01() {};
#elif (_TNS_X_TARGET)
T0000L16_21JUN2018_KTSTEA10_01() {};
#endif

//---------------------< Internal Function Prototypes >----------------------
void Process_Initialization( void );
void Msg_print( short i_type);
short LoadParameters( char *ac_PathCfgF,short i_reload );
short Process_Sysmesg_Handler( char *ac_msg );
//---------------------< External Variables >--------------------------------
//---------------------< Static and Global Variables >-----------------------
short			i_shutdown;
short			i_timeout_allow_vpc_set;
PREFIX_LIST		cg_prefix_owner_tfs;
PREFIX_LIST		cd_prefix_owner_tfs;
ARP_LIST		arp_list;
VPC_STATUS		vpc_status;
//---------------------------------------------------------------------------
int main( int argc, char **argv )
{
	short				rc;
    short               i_res;
    short               i_err;
    short               event;
    short               mapversion;
    short               nbrcomps;
    short               outbuflen;
    short               mtype;
    short               i_msg_id;
    short               Stop;
    short               i_allow_all;
    short				i_send_to_map_proxy;
    short				i_send_relay;
    short				i_ask_gtt;
    long                l_pc;
    char				c_check_pc;
    char                ac_cd[MAX_INS_STRING_LENGTH +1];
    char                *outbuf = NULL;
    fw_route_infod      routeinfop;     // pointer to routing info
    fw_sel_inparsed     p_sel;          // pointer to SEL parsed elements structure
    transactionId       transaction;
    dialogueStuff       dialogue;
    EXTERNAL_REF		*ExternalReference;
    ts_data             *ts;
    gtt_data            *gtt;

//    DELAY(1000);

	Stop        				 = 0;
	i_shutdown  				 = 0;
	i_ask_gtt     				 = 0;
	outbuflen   				 = 0;

	i_timeout_allow_vpc_set 	 = 0;
	i_cg_prefix_owner_tfs_loaded = 0;
	i_cd_prefix_owner_tfs_loaded = 0;
	i_stat_fw_param_loaded  	 = 0;
	c_check_pc 					 = CHECK_PC_AVAILABILITY_OFF;

    Process_Initialization();

	log_(LOG_DEBUG2,"%s: TS-DATA:[%d] - GTT-DATA:[%d]",
			__FUNCTION__,
			sizeof(ts_data),
			sizeof(gtt_data));

    //
    // Load ARP Dbase into memory
    //
    if( i_romun_enable == 1 )
    {
    	if( (i_err = Load_ARP_List( ac_path_arp_db,
    					   	   	    &arp_list )) )
    	{
			EVT_manage( EVTN_LOAD_ARP_DB_ERROR,
						0,
						0,
						'A',
						"Loading ARP DB Err.[%d]",
						i_err );

			log_( LOG_ERROR,"Loading ARP DB Err.[%d] - [%s]",
					i_err,
					ac_path_arp_db);
    	}
    	else
    	{
    		EVT_manage( EVTN_LOAD_ARP_DB_OK,
						0,
						0,
						'A',
						"Loading ARP DB Ok" );

    		log_( LOG_INFO,"Loading ARP items successfully - [%s]",ac_path_arp_db);

    	}
    }

    if( !Stop )
    {
		if( Load_Prefix_List( ac_cg_prefix_list_owner_tfs,
							  &cg_prefix_owner_tfs ) )
		{
			Stop = 1;

			EVT_manage( EVTN_LOAD_CG_PREFIX_LIST_OWNER_TFS_ERROR,
						0,
						0,
						'A',
						"Loading CG PREFIX OWNER TFS Err" );

			log_( LOG_ERROR,"Loading CG PREFIX OWNER TFS Err - [%s]",ac_cg_prefix_list_owner_tfs);
		}
		else
		{
			i_cg_prefix_owner_tfs_loaded = 1;

			EVT_manage( EVTN_LOAD_CG_PREFIX_LIST_OWNER_TFS_OK,
						0,
						0,
						'A',
						"Loading CG PREFIX OWNER TFS Ok" );


			log_( LOG_INFO,"Loading CG PREFIX OWNER TFS successfully - [%s]",ac_cg_prefix_list_owner_tfs);
		}
    }

    if( !Stop )
    {
		if( Load_Prefix_List( ac_cd_prefix_list_owner_tfs,
							  &cd_prefix_owner_tfs ) )
		{
			Stop = 1;

			EVT_manage( EVTN_LOAD_CD_PREFIX_LIST_OWNER_TFS_ERROR,
						0,
						0,
						'A',
						"Loading CD PREF. OWNER TFS Err" );

			log_( LOG_ERROR,"Loading CD PREFIX OWNER TFS Err - [%s]",ac_cd_prefix_list_owner_tfs);
		}
		else
		{
			i_cd_prefix_owner_tfs_loaded = 1;

			EVT_manage( EVTN_LOAD_CD_PREFIX_LIST_OWNER_TFS_OK,
						0,
						0,
						'N',
						"Loading CD PREFIX OWNER TFS Ok" );


			log_( LOG_INFO,"Loading CD PREFIX OWNER TFS successfully - [%s]",ac_cd_prefix_list_owner_tfs);
		}
    }

	if( !Stop )
	{
		// Set timer for bump stat
		if( SetTimerBump_(l_stat_bump_interval,TAG_BUMP))
		{
			EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
						0,
						i_interval_time,
						'A',
						"SIGNALTIMEOUT_() Err. - Bump Stat" );
		}

		if(SIGNALTIMEOUT_( (long)(l_timeout_reload + (long)(30*(long)(JULIANTIMESTAMP(0)%100))),
							0,
							TAG_RELOAD_PARAM ) )
		{
			EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
						0,
						i_interval_time,
						'A',
						"SIGNALTIMEOUT_() Err. - Reload Parameters" );
		}
	}

    // Main Loop
    while ( !Stop )
    {
        rc = FW2_TCAP_Receive ( &event, &mtype,
                                &mapversion, &nbrcomps,
                                &routeinfop, &p_sel,
                                &transaction, &outbuf,
                                &outbuflen, &dialogue );

		log_(LOG_DEBUG2,"%s: FW2_TCAP_Receive() : RC[%d] - RX Buffer len[%d]",
					__FUNCTION__,
					rc,
					outbuflen);

		if ( rc == FW_RCV_OK )
        {
        	switch ( event )
        	{
            	case FW_RCV_OTHER_MSG:
            	{
            		i_msg_id = *(short *)outbuf;

            		switch( i_msg_id )
            		{
                    	case GTT_TAG: // Incoming message from GTT
                    	{
                    		if( outbuflen == sizeof(gtt_data) )
                    		{
                    			AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_MESG_FROM_GTT);

								log_(LOG_DEBUG2,"%s: RX buffer from GTT server with length [%d]",
										__FUNCTION__,
										outbuflen);

								gtt = (gtt_data *)outbuf;

								ExternalReference = (EXTERNAL_REF *)gtt->external_reference;

								vpc_status.i_net_id = GetNetworkID_Default();

								switch( ExternalReference->c_opcode_req )
								{
									case MAP_ERR_REQ:   // #1
									{
										SetThroughputStat( ExternalReference->Ts_in,
														   ExternalReference->c_from );

										i_err = TCAP_Map_Error2( gtt );

										if( i_err )
										{
											i_shutdown = 1;

											AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_TCAP_MAP_ERROR_SENT_KO);
											log_(LOG_ERROR,"TCAP_Map_Error2 failed with Err.[%d] -",i_err);
										}
										else
										{
											AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_TCAP_MAP_ERROR_SENT_OK);
											log_(LOG_DEBUG,"TCAP_Map_Error2 sent OK");
										}

										break;
									}

									case TCAP_ABORT_REQ:    // #2
									{
										SetThroughputStat( ExternalReference->Ts_in,
														   ExternalReference->c_from );

										i_err = TCAP_User_Abort2( gtt );

										if( i_err )
										{
											i_shutdown = 1;

											AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_USER_ABORT_SENT_KO);
											log_(LOG_ERROR,"TCAP_User_Abort2 Req failed with Err.[%d] -",i_err);
										}
										else
										{
											AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_USER_ABORT_SENT_OK);
											log_(LOG_DEBUG,"TCAP_User_Abort2 sent OK");
										}

										break;
									}

									case TCAP_REJECT_REQ:   // #3
									{
										SetThroughputStat( ExternalReference->Ts_in,
														   ExternalReference->c_from );

										i_err = TCAP_Map_Reject2( gtt );

										if( i_err )
										{
											i_shutdown = 1;

											AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_REJECT_SENT_KO);
											log_(LOG_ERROR,"TCAP_Reject2 Req failed with Err.[%d] -",i_err);
										}
										else
										{
											AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_REJECT_SENT_OK);
											log_(LOG_DEBUG,"TCAP_Map_Reject2 sent OK");
										}

										break;
									}

									case RELAY_REQ:
									case FORCE_RELAY_REQ:
									default:
									{
										c_check_pc   = CHECK_PC_AVAILABILITY_ON;
										l_pc 	   	 = 0;
										i_send_relay = 1; // default to send

										if( gtt->ResultCode == GTT_RESULT_SUCCESS )
										{
											i_send_to_map_proxy = 0;

											if( gtt->c_dualimsi_flag == 0x01 ) // Dual IMSI
											{
												if( i_DualImsi_DPC_list_entries )
												{
													vpc_status.i_net_id = GetNetworkID_TSC();

													l_pc = GetDualImsiVDestPC( &vpc_status,
																			   i_DualImsi_DPC_list_entries,
																			   l_DualImsi_pc_list,
																			   i_internal_routing_strategy );

													if( l_pc == -1 )
													{
														l_pc = 0;
														log_(LOG_ERROR,"Dual IMSI DPC unavailable - Relaying towards HLR");
													}
													else
													{
														c_check_pc = CHECK_PC_AVAILABILITY_OFF;
														log_(LOG_DEBUG,"Getting Dual IIMSI DPC[%d]",l_pc);
													}

													vpc_status.i_net_id = GetNetworkID_Default();
												}
												else
												{
													log_(LOG_WARNING,"Dual IMSI MGT checked, but Dual IMSI has not been activated - Default relaying towards HLR");
												}
											}
											else
											{
												switch( gtt->c_romumb )
												{
													case TFS_LBO:
													case TFS_ARP:
													{
														if( i_romun_enable == 1 )
														{
															i_send_to_map_proxy = 1;

															log_(LOG_DEBUG,"Relay request[%X], Roaming Unb. activated",
																gtt->c_romumb);
														}
														else
														{
															log_(LOG_WARNING,"ROMUN - ARP-Id[%d] request[%X] set by TS, but Roaming Unb. has not been activated - Default Relaying towards HLR",
																gtt->i_arp_id,
																gtt->c_romumb);
														}

														break;
													}

													default:
													{
														if( i_romun_enable == 1 )
														{
															log_(LOG_DEBUG,"Relay request[%X], Roaming Unb. activated - NO LBO & NO ARP - Relaying towards HLR",
																gtt->c_romumb);
														}

														break;
													}
												}

												if( i_send_to_map_proxy )
												{
													if( gtt->c_romumb == TFS_LBO )
													{
														l_pc 	   = l_map_pxy_lbo_dpc;
														c_check_pc = CHECK_PC_AVAILABILITY_OFF;

														log_(LOG_WARNING,"ROMUN - LBO request[%X] set by TS, MAP Pxy LBO DPC[%ld]",
																gtt->c_romumb,
																l_pc);
													}
													else // ARP + LBO
													{
														// found DPC from ARP List
														i_err = Find_ARP( &arp_list,
																		  gtt->i_arp_id,
																		  &l_pc );

														if( i_err )
														{
															c_check_pc = CHECK_PC_AVAILABILITY_OFF;
															log_(LOG_DEBUG,"ROMUN - ARP-Id[%d] request[%X] set by TS, MAP Pxy ARP DPC[%ld]",
																	gtt->i_arp_id,
																	gtt->c_romumb,
																	l_pc);
														}
														else
														{
															log_(LOG_ERROR,"ROMUN - ARP-Id[%d] not found, Default Relaying towards HLR ",
																gtt->i_arp_id);

															l_pc 				= 0;
															i_send_to_map_proxy = 0;
														}
													}

													if( c_check_pc == CHECK_PC_AVAILABILITY_OFF )
													{
														if( !CheckDPC( vpc_status.i_net_id,
																	   (unsigned long)l_pc ) )
														{
															log_(LOG_ERROR,"ROMUN - MAP PXY DPC[%d] unavailable, Relaying towards HLR",l_pc);
															c_check_pc 			= CHECK_PC_AVAILABILITY_ON;
															l_pc	   			= 0;
															i_send_to_map_proxy = 0;
														}
														else
														{
															log_(LOG_DEBUG,"ROMUN - MAP PXY DPC[%d] is available",l_pc);
														}
													}
												}
											}

											if( !l_pc )
											{
												if( gtt->c_E164 == 0x00 ) // E.214
												{
													if( i_FAI_set ) // relay FAI STP
													{
														gtt->query_response.numberingPlan = SPARE;

														vpc_status.i_net_id = GetNetworkID_STP();

														l_pc = GetValidDestPC( &vpc_status,
																			   i_DPC_list_entries,
																			   l_point_code_list,
																			   i_internal_routing_strategy );

														if( l_pc != -1 )
														{
															c_check_pc 	  = CHECK_PC_AVAILABILITY_OFF;

															// flag dualimsi has been reused and overwritten with 0x02 (FAI)
															gtt->c_dualimsi_flag = 0x02;

															log_(LOG_DEBUG,"FAI set - Relaying with DPC[%ld]",l_pc);
														}
														else
														{
															i_shutdown   = 0;
															i_send_relay = 0;

															log_(LOG_WARNING,"FAI has been activated but No DPC available...");
														}

														vpc_status.i_net_id = GetNetworkID_Default();
													}
												}
												else if( gtt->c_E164 == 0x01 ) // E.164
												{
													if( i_E164_set ) // relay to STP - routing on GT+SSN(default 6)
													{
														gtt->query_response.numberingPlan = SPARE;

														vpc_status.i_net_id = GetNetworkID_STP();

														l_pc = GetValidDestPC( &vpc_status,
																			   i_DPC_list_entries,
																			   l_point_code_list,
																			   i_internal_routing_strategy );

														if( l_pc != -1 )
														{
															c_check_pc 	  = CHECK_PC_AVAILABILITY_OFF;

															// flag dualimsi has been reused and overwritten with 0x03 (No FAI but new E.164 routing)
															gtt->c_dualimsi_flag = 0x03;

															log_(LOG_DEBUG,"E.164 set routing on GT+SSN - Relaying with DPC[%ld]",l_pc);
														}
														else
														{
															i_shutdown   = 0;
															i_send_relay = 0;

															log_(LOG_WARNING,"E.164 set routing on GT+SSN has been activated but No DPC available...");
														}

														vpc_status.i_net_id = GetNetworkID_Default();
													}
												}
											}

											if( i_send_relay )
											{
												// relay
												if( (i_res = Sent_Relay_Msg( &vpc_status,
																			 l_pc,
																			 c_check_pc,
																			 gtt )) )
												{
													if(!i_send_to_map_proxy)
														AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_RELAY_SENT_KO);
													else
														AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_RELAY_MPXY_SENT_KO);

													if(i_res == -1 ||
													   i_res == -3)
													{
														i_shutdown = 1;
													}
												}
												else
												{
													if(!i_send_to_map_proxy)
														AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_RELAY_SENT_OK);
													else
														AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_RELAY_MPXY_SENT_OK);
												}
											}
											else
											{
												AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_RELAY_SENT_KO);
											}
										}
										else
										{
											memset( ac_cd,
													0x00,
													sizeof(ac_cd) );

											memcpy( ac_cd,
													gtt->query_data.address.value,
													gtt->query_data.address.length );

											if( gtt->c_E164 == 0x00 ) // E.214
											{
												if( i_FAI_set ) // relay FAI STP
												{
													i_fault_mngt_strategy = 2;

													vpc_status.i_net_id = GetNetworkID_STP();

													log_(LOG_DEBUG,"FAI set, force strategy[2] to use DPC List");
												}
												else
												{
													AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_ERROR_FROM_GTT);

													// Error from GTT
													EVT_manage( EVTN_GTT_ERROR_CODE,
																0,
																0,
																'A',
																"Incoming GTT message with Err. Code[%d] - Cd[%s]",
																gtt->ResultCode,
																ac_cd );

													vpc_status.i_net_id = GetNetworkID_Default();
												}
											}
											else if( gtt->c_E164 == 0x01 ) // E.164
											{
												if( i_E164_set ) // relay to STP - routing on GT+SSN(default 6)
												{
													i_fault_mngt_strategy = 2;

													vpc_status.i_net_id = GetNetworkID_STP();

													log_(LOG_DEBUG,"E.164 set routing on GT+SSN, force strategy[2] to use DPC List");
												}
												else
												{
													AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_ERROR_FROM_GTT);

													// Error from GTT
													EVT_manage( EVTN_GTT_ERROR_CODE,
																0,
																0,
																'A',
																"Incoming GTT message with Err. Code[%d] - Cd[%s]",
																gtt->ResultCode,
																ac_cd );

													vpc_status.i_net_id = GetNetworkID_Default();
												}
											}

											switch( i_fault_mngt_strategy )
											{
												case 0: //  continue...
												{
													i_shutdown = 0;

													if( (!i_E164_set && gtt->c_E164 == 0x01) || // relay to STP - routing on GT+SSN(default 6)
														(!i_FAI_set && gtt->c_E164 == 0x00) )   // relay FAI STP
													{
														log_(LOG_WARNING,"Incoming GTT message with Err. Code[%d] - Cd[%s:%s] - Fault Strategy set to NO OPERATION TO DO",
																gtt->ResultCode,
																ac_cd,
																(gtt->c_E164 == 0x01?"E.164":"E.214"));
													}

													break;
												}

												case 1: // VPC down
												{
													i_shutdown = 1;

													if( (!i_E164_set && gtt->c_E164 == 0x01) || // relay to STP - routing on GT+SSN(default 6)
														(!i_FAI_set && gtt->c_E164 == 0x00) )   // relay FAI STP
													{
														log_(LOG_WARNING,"Incoming GTT message with Err. Code[%d] - Cd[%s:%s] - Fault Strategy set to VPC down",
																gtt->ResultCode,
																ac_cd,
																(gtt->c_E164 == 0x01?"E.164":"E.214"));
													}

													break;
												}

												case 2: // use point code list
												{
													if( (!i_E164_set && gtt->c_E164 == 0x01) || // relay to STP - routing on GT+SSN(default 6)
														(!i_FAI_set && gtt->c_E164 == 0x00) )   // relay FAI STP
													{
														log_(LOG_WARNING,"Incoming GTT message with Err. Code[%d] - Cd[%s:%s] - Fault Strategy set to use DPC list",
																gtt->ResultCode,
																ac_cd,
																(gtt->c_E164 == 0x01?"E.164":"E.214"));
													}

													// relay STP
													gtt->query_response.numberingPlan = SPARE;

													l_pc = GetValidDestPC( &vpc_status,
																		   i_DPC_list_entries,
																		   l_point_code_list,
																		   i_internal_routing_strategy );

													if( l_pc != -1 )
													{
														c_check_pc = CHECK_PC_AVAILABILITY_OFF;

														if( gtt->c_E164 == 0x00 ) // E.214
														{
															if( i_FAI_set )// relay FAI STP
															{
																// flag dualimsi has been reused and overwritten with 0x02 (FAI)
																gtt->c_dualimsi_flag = 0x02;

																log_(LOG_DEBUG,"FAI set - Relaying with DPC[%ld]",l_pc);
															}
															else
															{
																log_(LOG_WARNING,"GTT Point Code not found - Relaying with DPC[%ld]",l_pc);
															}
														}
														else if( gtt->c_E164 == 0x01 ) // E.164
														{
															if( i_E164_set ) // relay to STP - routing on GT+SSN(default 6)
															{
																// flag dualimsi has been reused and overwritten with 0x03 (No FAI but new E.164 routing)
																gtt->c_dualimsi_flag = 0x03;

																log_(LOG_DEBUG,"E.164 set routing on GT+SSN - Relaying with DPC[%ld]",l_pc);
															}
															else
															{
																log_(LOG_WARNING,"GTT Point Code not found - Relaying with DPC[%ld]",l_pc);
															}
														}

														if( (i_res = Sent_Relay_Msg( &vpc_status,
																					 l_pc,
																					 c_check_pc,
																					 gtt )) )
														{
															AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_RELAY_SENT_KO);

															if( i_res == -1 ||
																i_res == -3 )
																i_shutdown = 1;
														}
														else
														{
															AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_RELAY_SENT_OK);
														}
													}
													else
													{
														i_shutdown = 0;
													}

													vpc_status.i_net_id = GetNetworkID_Default();

													break;
												}

												default:
												{
													i_shutdown = 0;

													break;
												}
											}
										}

										break;
									}
								}
                    		}
                    		else
                    		{
                    			log_(LOG_ERROR,"%s: RX unexpected buffer len[%d], from GTT Server",
										__FUNCTION__,
										outbuflen);
                    		}

                            break;
                        }

                        case TS_TAG:  // Incoming msg from TS Manager
                        {
                            if( outbuflen == sizeof(ts_data) )
                            {
                            	AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_MESG_FROM_TS);

								ts = (ts_data *)outbuf;
								ExternalReference = (EXTERNAL_REF *)ts->external_reference;

								SetThroughputStat( ExternalReference->Ts_in,
												   ExternalReference->c_from );

								log_(LOG_DEBUG2,"%s: RX buffer from TS Manager with length [%d]",
										__FUNCTION__,
										outbuflen);

								if( !ts->ResultCode )
								{
									switch( (short)ts->ResultType )
									{
										case RELAY_REQ:     // #0
										{
											// Ask GTT the PC from MGT to relay
											i_ask_gtt = 1; // to RELAY_REQ in GTT manage scope

											break;
										}

										case MAP_ERR_REQ:   // #1
										{
											if( i_ask_GT_to_GTT_enable )
											{
												// ask GTT the GT from MGT
												i_ask_gtt = 1; // to TCAP_Map_Error2 in GTT manage scope
											}
											else
											{
												i_err = TCAP_Map_Error( ts );

												if( i_err )
												{
													i_shutdown = 1;

													AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_TCAP_MAP_ERROR_SENT_KO);
													log_(LOG_ERROR,"TCAP_Map_Error failed with Err.[%d]",i_err);
												}
												else
												{
													AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_TCAP_MAP_ERROR_SENT_OK);
													log_(LOG_DEBUG,"TCAP_Map_Error sent OK");
												}
											}

											break;
										}

										case TCAP_ABORT_REQ:    // #2
										{
											if( i_ask_GT_to_GTT_enable )
											{
												// ask GTT the GT from MGT
												i_ask_gtt = 1; // to TCAP_User_Abort2 in GTT manage scope
											}
											else
											{
												i_err = TCAP_User_Abort( ts );

												if( i_err )
												{
													i_shutdown = 1;

													AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_USER_ABORT_SENT_KO);
													log_(LOG_ERROR,"TCAP_User_Abort Req failed with Err.[%d]",i_err);
												}
												else
												{
													AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_USER_ABORT_SENT_OK);
													log_(LOG_DEBUG,"TCAP_User_Abort sent OK");
												}
											}

											break;
										}

										case TCAP_REJECT_REQ:   // #3
										{
											if( i_ask_GT_to_GTT_enable )
											{
												// ask GTT the GT from MGT
												i_ask_gtt = 1; // to TCAP_Map_Reject2 in GTT manage scope
											}
											else
											{
												i_err = TCAP_Map_Reject( ts );

												if( i_err )
												{
													i_shutdown = 1;

													AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_REJECT_SENT_KO);
													log_(LOG_ERROR,"TCAP_Map_Reject Req failed with Err.[%d]",i_err);
												}
												else
												{
													AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_REJECT_SENT_OK);
													log_(LOG_DEBUG,"TCAP_Map_Reject sent OK");
												}
											}

											break;
										}

										default:
										{
											i_ask_gtt      = 1;
											ts->ResultType = FORCE_RELAY_REQ; // Force ResultType to relay request

											AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_UNKNOWN_TS_RESULT_CODE);

											log_(LOG_WARNING,"RX unknown result type[%d] from TS - Relay forced",ts->ResultType);

											break;
										}
									}

									// Relay or send LU to MAP Proxy for ROAMING UNBLUNDING
									if( i_ask_gtt )
									{
										P2_MTS_TAG_DEF mts_addr_GTT;
										P2_MTS_TAG_DEF mts_addr_RESP;

										i_ask_gtt = 0;

										memset(&mts_addr_GTT,0x00, sizeof(P2_MTS_TAG_DEF));
										memset(&mts_addr_RESP,0x00, sizeof(P2_MTS_TAG_DEF));

										if( ts->ResultType == RELAY_REQ )
										{
											log_(LOG_DEBUG,"Relay has been requested by TS Manager for IMSI[%.*s]",
													ts->imsi.length,
													ts->imsi.value);
										}

										mts_addr_GTT.task_id        = i_taskid_gtt;
										mts_addr_GTT.server_class   = i_serverclass_gtt;
										mts_addr_GTT.cpu            = 0;

										mts_addr_RESP.task_id       = i_taskid_mapout;
										mts_addr_RESP.server_class  = i_serverclass_mapout;
										mts_addr_RESP.cpu           = i_my_cpu;

										// sent to GTT
										i_err = Sent_Request_to_GTT( &mts_addr_GTT,
																	 &mts_addr_RESP,
																	 &ExternalReference->routeinfo,
																	 (transactionId *)(ExternalReference->ac_transaction),
																	 (short)(ExternalReference->c_map_version),
																	 ExternalReference->c_map_op_code,
																	 ExternalReference->out_buffer,
																	 ExternalReference->out_buff_len,
																	 MAPOUT_GTT_MAPOUT,
																	 ExternalReference->c_orig_cpu,
																	 ts->ResultType,
																	 ts->c_tcap_map_errorcode,
																	 ExternalReference->c_invoke_id,
																	 ts->i_arp_id,
																	 ts->c_romumb,
																	 CHECK_SCCP_CG_CD_ADDRESS_PREFIX,
																	 "---",
																	 &cg_prefix_owner_tfs,
																	 &cd_prefix_owner_tfs );

										 if( i_err )
										 {
											 AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_GTT_REQ_KO);

											 if( i_err == -1 ||
												 i_err == -3)
											 {
												 i_shutdown = 1;
											 }

											 log_(LOG_ERROR,"Err.[%d] - Sending Req. to GTTS[T:%d;S:%d] failure",
														 i_err,
														 i_taskid_gtt,
														 i_serverclass_gtt);
										 }
										 else
										 {
											 AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_GTT_REQ_OK);
											 log_(LOG_DEBUG,"Sent_Request_to_GTT() sent OK");
										 }
									}
								}
								else
								{
									i_shutdown = 1;

									AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_ERROR_FROM_TS);

									// Error from TS
									EVT_manage( EVTN_TS_ERROR_CODE,
												0,
												0,
												'A',
												"Incoming TS message with Err. Code [%d]",
												ts->ResultCode );

									log_(LOG_WARNING,"Incoming TS message with Err.Code[%d]",ts->ResultCode);
								}
                            }
                            else
                            {
                            	log_(LOG_ERROR,"%s: RX unexpected buffer len[%d], from TS Manager",
										__FUNCTION__,
										outbuflen);
                            }

                            break;
                        }

                        default:
                        {
                        	AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_UNKNOWN_IPC_MESG_REC);

                            log_(LOG_WARNING,"RX unknown IPC message tag [%d]",i_msg_id);

                            break;
                        }
                    }

                    if( i_shutdown &&
                    	!i_internal_routing_strategy &&
                    	vpc_status.i_vpc )
					{
                    	// shutdown TGDS Virtual Point Code
						i_shutdown  = 0;
						i_allow_all = 0;

						vpc_status.i_mode = VPC_DOWN;

						if( !(i_res = VPC_Status( &vpc_status )) )
						{
							AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_SHUTDOWN_PC_REQ_OK);

							EVT_manage( EVTN_PROHIBIT_VPC_OK,
										0,
										i_interval_time,
										'A',
										"SHUTDOWN VPC[%d] OK",
										vpc_status.i_vpc );

							log_(LOG_WARNING,"SHUTDOWN VPC[%d] OK", vpc_status.i_vpc);

							i_allow_all++;
						}
						else
						{
							if(i_res != P2_SS7_ALREADY_PROHIB)
							{
								AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_SHUTDOWN_PC_REQ_KO);

								EVT_manage( EVTN_PROHIBIT_VPC_KO,
											0,
											i_interval_time,
											'A',
											"SHUTDOWN VPC[%d] failed - Err.[%d]",
											vpc_status.i_vpc,
											i_res );

								log_(LOG_ERROR,"SHUTDOWN VPC[%d] failed - Err.[%d]",
										vpc_status.i_vpc,
										i_res);
							}
							else
							{
								if(!i_timeout_allow_vpc_set)
								{
									AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_SHUTDOWN_PC_REQ_OK);

									EVT_manage( EVTN_PROHIBIT_VPC_OK,
												0,
												i_interval_time,
												'A',
												"VPC[%d] already down",
												vpc_status.i_vpc );

									log_(LOG_WARNING,"VPC[%d] already down",vpc_status.i_vpc);
								}

								i_allow_all++;
							}
						}

						if( i_allow_all )
						{
							if( i_auto_allow_vpc && !i_timeout_allow_vpc_set )
							{
								if(!SIGNALTIMEOUT_(l_timeout_allow_vpc,0,TAG_ALLOW_VPC))
									i_timeout_allow_vpc_set = 1;
								else
								{
									EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
												0,
												i_interval_time,
												'A',
												"SIGNALTIMEOUT_() Err. - Allow VPC" );
								}
							}
						}
					}

                    break;
                }

            	case FW_RCV_SHUTDOWN_REQUEST:
                {
                	Stop = 1;
				    log_(LOG_WARNING,"RX FW_RCV_SHUTDOWN_REQUEST event");

                    break;
                }

                case FW_RCV_COMMAND:
                case FW_RCV_PROCESS_SIGNALTIMEOUT:
                {
                    Stop = Process_Sysmesg_Handler( outbuf );

                    break;
                }

                default:
                {
                	AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_UNKNOWN_FW_EVENT_REC);

                    EVT_manage( EVTN_FW_EVENT_UNKNOWN,
								0,
								i_interval_time,
								'A',
								"RX unknown framework event[%d] - Msg discarded",
								event );

                    log_(LOG_WARNING,"RX unknown framework event[%d] - Msg discarded",event);

                    break;
                }
            }    // switch (event)
        }    // if (rc == FW_RCV_OK)
        else
        {
            //  manage error
            EVT_manage( EVTN_FW_ERROR,
						0,
						i_interval_time,
						'A',
						"Err.[%d] - FW2_TCAP_Receive()",
						rc );

            log_(LOG_ERROR,"Err.[%d] - FW2_TCAP_Receive()",rc);
        }
    }

    i_res = (short)BumpStat();

	if( !i_res )
		log_( LOG_INFO, "Bump Statistics" );
	else
	{
		EVT_manage( EVTN_BUMP_ERROR,
					0,
					0,
					'A',
					"Err.[%d] - BumpStat()",
					i_res );

		log_( LOG_ERROR, "Err.[%d] - BumpStat()",i_res);
	}

	if( i_cg_prefix_owner_tfs_loaded )
		Unload_Prefix_List(&cg_prefix_owner_tfs);

	if( i_cd_prefix_owner_tfs_loaded )
		Unload_Prefix_List(&cd_prefix_owner_tfs);

	Unload_ARP_List(&arp_list);

    Msg_print( _STOP_ );

    log_close();

    return 0;
}

//
// manage system message
//
//
// Manage system message
//
short Process_Sysmesg_Handler( char *ac_msg )
{
    short            i_res;
    short			 i_err = 0;
    short            i_ret = 0;
    short            i_allow_all;
    long			 i_tmp_reload_param;
    PREFIX_LIST		 cg_prefix_owner_tfs_tmp;
    PREFIX_LIST		 cd_prefix_owner_tfs_tmp;
    ARP_LIST		 arp_list_tmp;
    IO_SYS_TIMEOUT   *signal;
    SYS_COMMAND      *cmd;

	signal = (IO_SYS_TIMEOUT *)ac_msg;

    switch( signal->id )
    {
        case SYS_MSG_TIME_TIMEOUT:
        {
			log_(LOG_DEBUG2,"%s: [SYS_MSG_TIME_TIMEOUT] - Sock[%d] Tag[%ld]",
						__FUNCTION__,
						signal->i_socket,
						signal->l_tag);

            switch ( signal->l_tag )
            {
                case TAG_RELOAD_PARAM:
                {
					if ( checkChgFile( ac_filecfg_oss ) )
					{
						if( !LoadParameters(ac_filecfg,RELOAD) )
						{
							EVT_manage( EVTN_PARAM_MISSING,
										0,
										i_interval_time,
										'A',
										"Missing parameter or fileini opened" );

							log_(LOG_WARNING, "Reloading parameters failed: missing parameter or fileini opened");
						}
						else
						{
							log_(LOG_DEBUG2, "%s: Reloading parameters successfully",__FUNCTION__);
						}
					}
					else
					{
						log_(LOG_DEBUG2, "%s: Reloading parameters not necessary",__FUNCTION__);
					}

					if( i_cg_prefix_owner_tfs_loaded )
					{
						if( Load_Prefix_List( ac_cg_prefix_list_owner_tfs,
											  &cg_prefix_owner_tfs_tmp ) )
						{
							EVT_manage( EVTN_RELOAD_CG_PREFIX_LIST_OWNER_TFS_ERROR,
										0,
										0,
										'A',
										"Reloading CG PREFIX OWNER TFS Err" );

							log_( LOG_ERROR,"Reloading CG PREFIX OWNER TFS Err - [%s]",ac_cg_prefix_list_owner_tfs);
						}
						else
						{
							Unload_Prefix_List(&cg_prefix_owner_tfs);

							cg_prefix_owner_tfs = cg_prefix_owner_tfs_tmp;

							log_( LOG_DEBUG2,"%s: Reloading CG PREFIX OWNER TFS successfully - [%s]",
									__FUNCTION__,
									ac_cg_prefix_list_owner_tfs);
						}
					}

					if( i_cd_prefix_owner_tfs_loaded )
					{
						if( Load_Prefix_List( ac_cd_prefix_list_owner_tfs,
											  &cd_prefix_owner_tfs_tmp ) )
						{
							EVT_manage( EVTN_RELOAD_CD_PREFIX_LIST_OWNER_TFS_ERROR,
										0,
										0,
										'A',
										"Reloading CD PREFIX OWNER TFS Err" );

							log_( LOG_ERROR,"Reloading CD PREFIX OWNER TFS Err - [%s]",ac_cd_prefix_list_owner_tfs);
						}
						else
						{
							Unload_Prefix_List(&cd_prefix_owner_tfs);

							cd_prefix_owner_tfs = cd_prefix_owner_tfs_tmp;

							log_( LOG_DEBUG2,"%s: Reloading CD PREFIX OWNER TFS successfully - [%s]",
									__FUNCTION__,
									ac_cd_prefix_list_owner_tfs );
						}
					}

					if( i_romun_enable == 1 )
					{
						if(	( i_err = Load_ARP_List( ac_path_arp_db,
												     &arp_list_tmp )) )
						{
							EVT_manage( EVTN_LOAD_ARP_DB_ERROR,
										0,
										0,
										'A',
										"Reloading ARP DB Err.[%d]",
										i_err);

							log_( LOG_ERROR,"Reloading ARP DB Err.[%d] - [%s]",i_err,ac_path_arp_db);
						}
						else
						{
							Unload_ARP_List(&arp_list);

							arp_list = arp_list_tmp;

							log_( LOG_DEBUG2,"%s: Reloading ARP DB successfully - [%s]",
									__FUNCTION__,
									ac_path_arp_db);
						}
					}

					if(SIGNALTIMEOUT_( (long)(l_timeout_reload + (long)(30*(long)(JULIANTIMESTAMP(0)%100))),
										0,
										TAG_RELOAD_PARAM ) )
					{
						EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
									0,
									i_interval_time,
									'A',
									"SIGNALTIMEOUT_() Err. - Reload Parameters" );
					}

                    break;
                }

                case TAG_BUMP:
                {
                    // Bump
                    i_res = (short)BumpStat();

                    if( !i_res )
                    {
                    	log_( LOG_DEBUG2, "%s: Bump Statistics",__FUNCTION__ );
                    }
                    else
                    {
                        EVT_manage( EVTN_BUMP_ERROR,
									0,
									i_interval_time,
									'A',
									"Err.[%d] BumpStat()",
									i_res );

                        log_(LOG_ERROR, "Err.[%d] - BumpStat()",i_res);
                    }

                    if( SetTimerBump_(l_stat_bump_interval,TAG_BUMP ))
					{
						EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
									0,
									i_interval_time,
									'A',
									"SIGNALTIMEOUT_() Err. - BumpStat()" );
					}

                    break;
                }

                case TAG_ALLOW_VPC:
                {
                    i_shutdown  			= 0;
                    i_allow_all 			= 0;
					i_timeout_allow_vpc_set = 0;

					vpc_status.i_mode = VPC_UP;

					if( !(i_res = VPC_Status( &vpc_status )) )
					{
						AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_ALLOW_PC_REQ_OK);

						EVT_manage( EVTN_ALLOW_VPC_OK,
									0,
									i_interval_time,
									'A',
									"VPC[%d] is alive",
									vpc_status.i_vpc );

						log_(LOG_DEBUG2,"%s: VPC[%d] is alive",
								__FUNCTION__,
								vpc_status.i_vpc);

						i_allow_all++;
					}
					else
					{
						if(i_res == P2_SS7_ALREADY_ALLOWD)
						{
							AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_ALLOW_PC_REQ_OK);

							EVT_manage( EVTN_ALLOW_VPC_OK,
										0,
										i_interval_time,
										'A',
										"VPC[%d] is already alive",
										vpc_status.i_vpc );

							log_(LOG_DEBUG2,"%s: VPC[%d] is already alive",
									__FUNCTION__,
									vpc_status.i_vpc);

							i_allow_all++;
						}
						else
						{
							AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPOUT",TOT_ALLOW_PC_REQ_KO);

							EVT_manage( EVTN_ALLOW_VPC_OK,
										0,
										i_interval_time,
										'A',
										"Allow VPC[%d] failed - Err.[%d] - retry",
										 vpc_status.i_vpc,
										 i_res );


							log_(LOG_ERROR,"VPC[%d] is down - Err.[%d] - retry",
										vpc_status.i_vpc,
										i_res);
						}
					}

                    if( i_allow_all )
                    {
                        if( i_auto_allow_vpc )
						{
                            if(!SIGNALTIMEOUT_(l_timeout_allow_vpc,0,TAG_ALLOW_VPC))
								i_timeout_allow_vpc_set = 1;
                            else
                            {
                            	EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
											0,
											i_interval_time,
											'A',
											"SIGNALTIMEOUT_() Err. - Allow VPC" );
                            }
						}
                    }

                    break;
                }
            }

            break;
        }

        case SYS_MSG_COMMAND:
        {
            cmd = (SYS_COMMAND *)ac_msg;
			cmd->ac_cmd[cmd->i_cnt] = 0;

			if( !strcmp(cmd->ac_cmd,"PARAMREFRESH") )
			{
				log_(LOG_DEBUG2,"%s: RX PARAMREFRESH request",__FUNCTION__);

				i_tmp_reload_param = (long)(JULIANTIMESTAMP(0)%100);

				if( i_tmp_reload_param < 3 )
					i_tmp_reload_param = 3;

				// shifting JULIANTIMESTAMP(0) + [3 - 33"]
				if( SIGNALTIMEOUT_((long)( 30 * i_tmp_reload_param ),0,TAG_RELOAD_PARAM) )
				{
					EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
								0,
								0,
								'A',
								"SIGNALTIMEOUT_() Err. - PARAMREFRESH" );

					log_(LOG_ERROR,"SIGNALTIMEOUT_() Err. - Reloading parameters" );
				}
				else
				{
					EVT_manage( EVTN_CMD_REFRESH_PARAM_OK,
								0,
								0,
								'N',
								"RX PARAMREFRESH request" );
				}
			}
			else
			{
				EVT_manage( EVTN_CMD_UNHANDLE,
							0,
							0,
							'A',
							"RX unhandle command[%s] request",
							cmd->ac_cmd );

				log_(LOG_ERROR,"RX unhandle cmd[%s] request",cmd->ac_cmd);
			}

            break;
        }

        case SYS_MSG_STOP_1:
        case SYS_MSG_STOP_2:
        {
            i_ret = 1;

            break;
        }
    }

    return i_ret;

} // End Of Procedure

// print start/stop message on log_
void Msg_print( short i_type )
{
    log_ (LOG_INFO, "**************************");
    log_ (LOG_INFO, "***                    ***");
    log_ (LOG_INFO, "***  Traffic Steering  ***");
    log_ (LOG_INFO, "***      MAP-OUT       ***");
    log_ (LOG_INFO, "***                    ***");
    log_ (LOG_INFO, "***       V 1.11       ***");
    log_ (LOG_INFO, "***                    ***");

    switch( i_type )
    {
        case _START_:
        {
        	EVT_manage( EVTN_START,
						0,
						0,
						'N',
						"[%s] started",
        				ac_my_process_name );

            log_ (LOG_INFO, "***      Started       ***");

            break;
        }

        case _STOP_:
        {
        	EVT_manage( EVTN_STOP,
						0,
						0,
						'N',
						"[%s] stopped by user",
						ac_my_process_name );

            log_ (LOG_INFO, "***      Stopped       ***");

            break;
        }
    }

    log_ (LOG_INFO, "***                    ***");
    log_ (LOG_INFO, "**************************");
}

/****************************************************************************
***  Module Name:  Process_Initialization                                  **
***                                                                        **
***  Description:  This module is responsible for processing all of the    **
***                run-time parameters and determining if the process      **
***                has been started under the Node or in a stand-alone     **
***                environment.                                            **
*****************************************************************************/
void Process_Initialization (void)
{
    short           rc;
    short           i_proch[20];
    short           i_maxlen = sizeof (ac_my_process_name);
    char            *wrk_str;
    FW_ACTabled     AC_List;

    if ((wrk_str = getenv ("FILEINI")) != NULL)
    {
        memset(ac_filecfg,0x00, sizeof(ac_filecfg));
		memset(ac_my_process_name,0x00, sizeof(ac_my_process_name));
        strncpy(ac_filecfg,wrk_str,sizeof(ac_filecfg)-1);

        PROCESSHANDLE_GETMINE_ (i_proch);
        PROCESSHANDLE_DECOMPOSE_ ( i_proch,
        						   &i_my_cpu,
                                   ,,,,,
                                   ac_my_process_name,
                                   i_maxlen,
                                   &i_maxlen, );

		setChgFile(ac_filecfg,ac_filecfg_oss);

        if(!LoadParameters(ac_filecfg,LOAD))
        {
        	exit(-1);
        }
        else
        {
            Msg_print( _START_ );

			// Initialize FWR
			AC_List.ac_array_entries = 0;
			rc = TCAP_InitializeFramework( &AC_List );

			if( rc != FW_IF_OK &&
				rc != FW_IF_NoOperation )
			{
				EVT_manage( EVTN_FW_INITIALIZE_KO,
						    0,
						    0,
						    'A',
						    "FW initialization failure - Err.[%d] - Exit",
						    rc );

			    log_(LOG_ERROR,"FW initialization failure - Exit" );

			    exit(-1);
			}

			L_INITIALIZE_END();

			if(!Stat_init( "",
						   "",
						   "",
						   i_stat_group,
						   i_stat_max_register,
						   S_MAX_IDX_NUMBER ))
			{
				EVT_manage( EVTN_STAT_NOT_INIT,
							0,
							0,
							'A',
							"Stat_init failure - Exit" );

				log_(LOG_ERROR,"Stat_init failure - Exit");

				exit(-1);
			}
			else
			{
				log_(LOG_INFO,"Network-Name[%s] - NI[TFS(%d)|STP(%d)|TSC(%d)] - TFS Int.Routing[%s] - TFS VPC[%d] - FAI[%s] - FAI SSN[%d] - E.164 GT+SSN[%s]",
							vpc_status.ac_net_name,
							GetNetworkID_Default(),
							GetNetworkID_STP(),
							GetNetworkID_TSC(),
							(i_internal_routing_strategy?"INTERNAL ROUTING SET":"NOT INTERNAL ROUTING SET"),
							vpc_status.i_vpc,
							(i_FAI_set?"FAI SET":"FAI UNSET"),
							(i_FAI_set?i_FAI_SSN:-1),
							(i_E164_set?"ON":"OFF"));

				setFW_networkId((char)GetNetworkID_Default());

				if(i_stat_fw_param_loaded)
				{
					if( (rc = (short)FW_StatOpen_No_Bump()) ) // Open FW stat without BUMP_STAT functionality
					{
						EVT_manage( EVTN_STAT_NOT_INIT,
									0,
									0,
									'A',
									"Initialize FW Stats failure - Err.[%d]",
									rc );


						log_(LOG_ERROR,"Initialize FW Stats failure - Err.[%d]", rc);
					}
					else
						log_(LOG_INFO,"TFS FW Stat_init successfully - FW Group[%d]", i_stat_fw_group);
				}
			}
        }
    }
    else
        exit(-1);
} // End Of Procedure: Process_Initialization

//
// Load parameters function. Load INI file
//
short LoadParameters( char *ac_PathCfgFile,
                      short i_reload )
{
    short	rc      = 0;
    short   ret     = 1;
    short	i_tmp;
    short	i;
    int     found   = 0;
    char    ac_value[255];
    char    *wrk_str;
    char    *ac_delimiters=",;-:";

    memset( &vpc_status,
    		0x00,
			sizeof(VPC_STATUS) );

    SetDefaultSSN( HLR ); // SSN=6 Default
    SetFAI_SSN( -1 );

    /*******************
	** [EVT]
	********************/
	if( !i_reload )
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "EVT",
								 "SSID-OWNER",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				strncpy(ac_cSSID_Owner,ac_value,sizeof(ac_cSSID_Owner)-1);

				rc = get_profile_string( ac_PathCfgFile,
										 "EVT",
										 "SSID-NUMBER",
										 &found,
										 ac_value );
				if(!rc)
				{
					if(found)
					{
						i_nSSID_Number = (short)atoi(ac_value);

						rc = get_profile_string( ac_PathCfgFile,
												 "EVT",
												 "SSID-VERSION",
												 &found,
												 ac_value );
						if(!rc)
						{
							if(found)
							{
								strncpy(ac_cSSID_Version,ac_value,sizeof(ac_cSSID_Version)-1);

								//
								//  initialize EVT on $0
								//
								if (!sspevt_init( "TFS-OUT", ac_cSSID_Owner, i_nSSID_Number, ac_cSSID_Version ) )
									EVT_manage_init();
								else
									ret = 0;
							}
							else
								ret = 0;
						}
						else
							ret = 0;
					}
					else
						ret = 0;
				}
				else
					ret = 0;
			}
			else
				ret = 0;
		}
		else
			ret = 0;
	}

	if(i_reload >= 0 && ret)
	{
		if(!i_reload)
			i_nbr_alert_msg = 1; // Default value 1 msg

		rc = get_profile_string( ac_PathCfgFile,
								 "EVT",
								 "NBR-ALERT-MSG",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				i_tmp = (short)atoi(ac_value);
				if(i_tmp < 0)
				{
					if(!i_reload)
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [EVT][NBR-ALERT-MSG] - Set to 1 msg" );
					}
					else
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [EVT][NBR-ALERT-MSG]" );
					}
				}
				else
					i_nbr_alert_msg = i_tmp;
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [EVT][NBR-ALERT-MSG] - Set to 1 msg" );
				}
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [EVT][NBR-ALERT-MSG]" );
		}
	}

	if(i_reload >= 0 && ret)
	{
		if(!i_reload)
			i_interval_time = 300; // Default value in seconds 300"

		rc = get_profile_string( ac_PathCfgFile,
								 "EVT",
								 "INTERVAL-ALERT-MSG-TIME",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				i_tmp = (short)atoi(ac_value);
				if(i_tmp < 0)
				{
					if(!i_reload)
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [EVT][INTERVAL-ALERT-MSG-TIME] - Set to 5'" );
					}
					else
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [EVT][INTERVAL-ALERT-MSG-TIME]" );
					}
				}
				else
					i_interval_time = i_tmp;
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [EVT][INTERVAL-ALERT-MSG-TIME] - Set to 5'" );
				}
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [EVT][INTERVAL-ALERT-MSG-TIME]" );
		}
	}

    /*******************
    ** [COMMON]
    ********************/
	if(i_reload >= 0 && ret)
	{
		if(!i_reload)
			l_timeout_reload = (long)(15*60*100); // 15'

		rc = get_profile_string( ac_PathCfgFile,
								"COMMON",
								"TIMEOUT-RELOAD-PARAM",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				l_timeout_reload= (long)(atol(ac_value)*60*100);
				if(l_timeout_reload < 6000)
				{
					l_timeout_reload = 6000;

					EVT_manage( EVTN_WRONG_PARAM,
								0,
								0,
								'A',
								"Wrong [COMMON][TIMEOUT-RELOAD-PARAM] - Set to 1'" );
				}
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [COMMON][TIMEOUT-RELOAD-PARAM] - Set to 15'" );
				}
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [COMMON][TIMEOUT-RELOAD-PARAM]" );
		}
	}

    if(i_reload >= 0 && ret)
    {
    	if(!i_reload)
    		i_mgt_test = 0; // default value

        rc = get_profile_string( ac_PathCfgFile,
                                "COMMON",
                                "MGT-TEST-CONTROL",
                                &found,
                                ac_value );
        if(!rc)
        {
            if(found)
            {
                i_mgt_test = (short)atoi(ac_value);
                if( i_mgt_test < 0 || i_mgt_test > 1 )
                {
                	if(!i_reload)
                	{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [COMMON][MGT-TEST-CONTROL] - 0 or 1" );
                	}
                	else
                	{
                		EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [COMMON][MGT-TEST-CONTROL]" );
                	}
                }
                else
                {
                    rc = get_profile_string( ac_PathCfgFile,
                                            "COMMON",
                                            "MGT-TEST",
                                            &found,
                                            ac_value );
                    if(!rc)
                    {
                        if(found)
                            strncpy(ac_cd_test,ac_value,sizeof(ac_cd_test)-1);
                        else
                            i_mgt_test = 0;
                    }
                    else
                        i_mgt_test = 0;
                }
            }
        }
    }

    /*******************
	**[PREFIX-ADDR-LIST]
	********************/
	if(!i_reload && ret )
	{
		rc = get_profile_string( ac_PathCfgFile,
								"PREFIX-ADDR-LIST",
								"SCCP-CALLING-PREFIX-LIST-OWNER-TFS",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				strncpy(ac_cg_prefix_list_owner_tfs,ac_value,sizeof(ac_cg_prefix_list_owner_tfs)-1);
			}
			else
			{
				ret = 0;
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PREFIX-ADDR-LIST][SCCP-CALLED-PREFIX-LIST-OWNER-TFS]" );
			}
		}
		else
		{
			ret = 0;
			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PREFIX-ADDR-LIST][SCCP-CALLED-PREFIX-LIST-OWNER-TFS]" );
		}
	}

	if(!i_reload && ret )
	{
		rc = get_profile_string( ac_PathCfgFile,
								"PREFIX-ADDR-LIST",
								"SCCP-CALLED-PREFIX-LIST-OWNER-TFS",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				strncpy(ac_cd_prefix_list_owner_tfs,ac_value,sizeof(ac_cd_prefix_list_owner_tfs)-1);
			}
			else
			{
				ret = 0;
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PREFIX-ADDR-LIST][SCCP-CALLED-PREFIX-LIST-OWNER-TFS]" );
			}
		}
		else
		{
			ret = 0;
			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PREFIX-ADDR-LIST][SCCP-CALLED-PREFIX-LIST-OWNER-TFS]" );
		}
	}

    /*******************
    ** [PC]
    ********************/
    if(i_reload >= 0 && ret)
    {
    	if(!i_reload)
    		i_fault_mngt_strategy = 0; // default continue

        rc = get_profile_string( ac_PathCfgFile,
                                "PC",
                                "FAULT-MNGT-STRATEGY",
                                &found,
                                ac_value );
        if(!rc)
        {
            if(found)
            {
                i_fault_mngt_strategy = (short)atoi(ac_value);
                if( i_fault_mngt_strategy < 0 || i_fault_mngt_strategy > 2 )
                    i_fault_mngt_strategy = 0;
            }
            else
            {
            	EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PC][FAULT-MNGT-STRATEGY] - Set to 0");
            }
        }
        else
        {
            ret = 0;
            EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][FAULT-MNGT-STRATEGY]");
        }
    }

    if(i_reload >= 0 && ret)
    {
        rc = get_profile_string( ac_PathCfgFile,
                                "PC",
                                "POINT-CODE-LIST",
                                &found,
                                ac_value );
        if(!rc)
        {
            if(found)
            {
                i_DPC_list_entries = 0;
                strncpy(ac_pc_list,ac_value,sizeof(ac_pc_list)-1);

                memset ( (char *)&l_point_code_list[0],
                         NULL,
                         sizeof(long));

                for (i=0; i < DPC_LIST_MAX_SIZE; i++)
                {
                    if ( !i )
                        wrk_str = strtok(ac_pc_list, ac_delimiters);
                    else
                        wrk_str = strtok(NULL , ac_delimiters);

                    if ( !wrk_str )
                        break;

                    l_point_code_list[i] = (long)atol(wrk_str);
                }

                if( !i )
                {
                	ret = 0;
                	EVT_manage( EVTN_WRONG_PARAM,
								0,
								0,
								'A',
								"Wrong [PC][POINT-CODE-LIST] - No DPC set");
                }
                else
                {
                	i_DPC_list_entries = (short) i;

                	i_FAI_set  = 0; // default unset
                	i_E164_set = 0; // default unset

           	        rc = get_profile_string( ac_PathCfgFile,
           	                                 "PC",
                	                         "FAI-SET",
                	                         &found,
                	                         ac_value );
					if(!rc)
					{
						if(found)
						{
							i_FAI_set = (short)atoi(ac_value);

							switch( i_FAI_set )
							{
								case 0:
								{
									break;
								}

								case 1:
								{
									// ok
									rc = get_profile_string( ac_PathCfgFile,
															 "PC",
															 "FAI-SSN",
															 &found,
															 ac_value );
									if(!rc)
									{
										if(found)
										{
											i_FAI_SSN = (short)atoi(ac_value);
											SetFAI_SSN(i_FAI_SSN);
										}
										else
										{
											i_FAI_set = 0; // default not set

											EVT_manage( EVTN_PARAM_MISSING,
														0,
														0,
														'A',
														"Missing [PC][FAI-SSN] - FAI unset");
										}
									}
									else
									{
										i_FAI_set = 0; // default not set

										EVT_manage( EVTN_PARAM_MISSING,
													0,
													0,
													'A',
													"Missing [PC][FAI-SSN] - FAI unset");
									}

									break;
								}

								default:
								{
									i_FAI_set = 0; // default not set

									EVT_manage( EVTN_WRONG_PARAM,
												0,
												0,
												'A',
												"Wrong [PC][FAI-SET] - FAI unset");

									break;
								}
							}
						}
						else
						{
							i_FAI_set = 0; // default not set

							EVT_manage( EVTN_WRONG_PARAM,
										0,
										0,
										'A',
										"Wrong [PC][FAI-SET] - FAI unset");
						}
					}

					rc = get_profile_string( ac_PathCfgFile,
											 "PC",
											 "ROUTING-E164-GT-SSN",
											 &found,
											 ac_value );
					if(!rc)
					{
						if(found)
						{
							i_E164_set = (short)atoi(ac_value);

							switch( i_E164_set )
							{
								case 0:
								case 1:
								{
									break;
								}

								default:
								{
									i_E164_set = 0; // default not set

									EVT_manage( EVTN_WRONG_PARAM,
												0,
												0,
												'A',
												"Wrong [PC][ROUTING-E164-GT-SSN] - ROUTING-E164-GT-SSN unset");

									break;
								}
							}
						}
						else
						{
							i_E164_set = 0; // default not set

							EVT_manage( EVTN_WRONG_PARAM,
										0,
										0,
										'A',
										"Wrong [PC][ROUTING-E164-GT-SSN] - ROUTING-E164-GT-SSN unset");
						}
					}
                }
            }
            else
            {
            	ret = 0;
            	EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PC][POINT-CODE-LIST]");
            }
        }
        else
        {
            ret = 0;
            EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][POINT-CODE-LIST]");
        }
    }

    if(i_reload >= 0 && ret)
	{
    	i_DualImsi_DPC_list_entries = 0;

		rc = get_profile_string( ac_PathCfgFile,
								"PC",
								"TSC-PC-LIST",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				strncpy(ac_pc_list,ac_value,sizeof(ac_pc_list)-1);

				memset ( (char *)&l_DualImsi_pc_list[0],
						 NULL,
						 sizeof(long));

				for (i=0; i < DPC_LIST_MAX_SIZE; i++)
				{
					if ( !i )
						wrk_str = strtok(ac_pc_list, ac_delimiters);
					else
						wrk_str = strtok(NULL , ac_delimiters);

					if ( !wrk_str )
						break;

					l_DualImsi_pc_list[i] = (long)atol(wrk_str);
				}

				if( !i )
				{
					ret = 0;
					EVT_manage( EVTN_WRONG_PARAM,
								0,
								0,
								'A',
								"Wrong [PC][TSC-PC-LIST] - No DPC set");
				}
				else
				{
					i_DualImsi_DPC_list_entries = (short) i;
				}
			}
		}
	}

    if(i_reload >= 0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								"PC",
								"TFS-NET-NAME",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				strncpy(vpc_status.ac_net_name,ac_value,sizeof(vpc_status.ac_net_name)-1);
			}
			else
			{
				ret = 0;
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PC][TFS-NET-NAME]" );
			}
		}
		else
		{
			ret = 0;
			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][TFS-NET-NAME]" );
		}
	}

	if(i_reload >= 0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "PC",
								 "TFS-NET-ID",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				vpc_status.i_net_id = (unsigned short)atoi(ac_value);
				SetNetworkID_Default(vpc_status.i_net_id);
			}
			else
			{
				ret = 0;
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PC][TFS-NET-ID]" );
			}
		}
		else
		{
			ret = 0;
			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][TFS-NET-ID]" );
		}
	}

	if(i_reload >= 0 && ret)
	{
		SetNetworkID_TSC(vpc_status.i_net_id); // default
		SetNetworkID_STP(vpc_status.i_net_id); // default

		rc = get_profile_string( ac_PathCfgFile,
								 "PC",
								 "TSC-NET-ID",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				SetNetworkID_TSC((short)atoi(ac_value));
			}
		}

		if(i_reload >= 0 && ret)
		{
			rc = get_profile_string( ac_PathCfgFile,
									 "PC",
									 "STP-NET-ID",
									 &found,
									 ac_value );
			if(!rc)
			{
				if(found)
				{
					SetNetworkID_STP((short)atoi(ac_value));
				}
			}
		}
	}

	if(i_reload >= 0 && ret)
	{
		// To cause the INS Router to send a message with Route on Global Title set in the SCCPs called party address to an adjacent node (e.g. STP),
		// the application must send to some DPC that is NOT one of the local point codes.
		// A MTP3 Routing Label DPC value of zero results in correct routing of messages out of the INS to one of the nodes identified in the INS document Configuration Planning Guide.

		if(!i_reload)
			i_internal_routing_strategy = NO_INTERNAL_ROUTING_STRATEGY; // Default NO_INTERNAL_ROUTING_STRATEGY

		rc = get_profile_string( ac_PathCfgFile,
								 "PC",
								 "TFS-INTERNAL-ROUTING-STRATEGY",
								 &found,
								 ac_value );

		if(!rc)
		{
			if(found)
			{
				i_tmp = (short)atoi(ac_value);

				if( i_tmp < 0 ||
					i_tmp > 1 )
				{
					if(!i_reload)
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][TFS-INTERNAL-ROUTING-STRATEGY] - Set to 0" );
					}
					else
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][TFS-INTERNAL-ROUTING-STRATEGY] - 0 or 1" );
					}
				}
				else
					i_internal_routing_strategy = i_tmp;
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [PC][TFS-INTERNAL-ROUTING-STRATEGY] - Set to 0" );
				}
			}
		}
		else
		{
			if(!i_reload)
			{
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PC][TFS-INTERNAL-ROUTING-STRATEGY] - Set to 0" );
			}
		}
	}

	if(i_reload >= 0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "PC",
								 "TFS-VPC",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				if(i_internal_routing_strategy == INTERNAL_ROUTING_STRATEGY)
					vpc_status.i_vpc = 0; // forced to 0
				else
					vpc_status.i_vpc = (short)atoi(ac_value);
			}
			else
			{
				ret = 0;

				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PC][TFS-VPC]" );
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][TFS-VPC]" );
		}
	}

    if(i_reload >= 0 && ret)
    {
    	if(!i_reload)
    		i_auto_allow_vpc = 0;

        rc = get_profile_string( ac_PathCfgFile,
                                 "PC",
                                 "AUTO-ALLOW-VPC",
                                 &found,
                                 ac_value );
        if(!rc)
        {
            if(found)
            {
                i_tmp = (short)atoi(ac_value);
                if( i_tmp < 0 ||
                	i_tmp > 1 )
                {
                	if(!i_reload)
                	{
                		EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][AUTO-ALLOW-VPC] - Set to 0" );
                	}
                	else
                	{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][AUTO-ALLOW-VPC] - 0 or 1" );
                	}
                }
                else
                	i_auto_allow_vpc = i_tmp;
            }
            else
            {
            	if(!i_reload)
            	{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [PC][AUTO-ALLOW-VPC] - Set to 0" );
            	}
            	else
            	{
            		EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [PC][AUTO-ALLOW-VPC]" );
            	}
            }
        }
        else
        {
        	ret = 0;

        	EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][AUTO-ALLOW-VPC]" );
        }
    }

    if(i_reload >= 0 && ret)
    {
    	if(!i_reload)
    		l_timeout_allow_vpc = (long)(5*60*100); // 5'

        rc = get_profile_string( ac_PathCfgFile,
                                "PC",
                                "VPC-ALLOW-TIMEOUT",
                                &found,
                                ac_value );
        if(!rc)
        {
            if(found)
            {
            	l_timeout_allow_vpc = (long)(atol(ac_value)*60*100);
                if( l_timeout_allow_vpc < 0 )
                {
                	if(!i_reload)
                	{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][VPC-ALLOW-TIMEOUT] - Set to 5'" );
                	}
                	else
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][VPC-ALLOW-TIMEOUT]" );
					}
                }
            }
            else
            {
            	if(!i_reload)
            	{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [PC][VPC-ALLOW-TIMEOUT] - Set to 5'" );
            	}
            	else
            	{
            		EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [PC][VPC-ALLOW-TIMEOUT]" );
            	}
            }
        }
        else
        {
            ret = 0;

            EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][VPC-ALLOW-TIMEOUT]" );
        }
    }

    /*******************
	** [PC]
	********************/
	if(i_reload >= 0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "PC",
								 "HLR-SSN",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				i_hlr_ssn = (short)atoi(ac_value);
				if(i_hlr_ssn > 0)
					SetDefaultSSN( i_hlr_ssn );
			}
		}
	}

	/*******************
	** [IPC]
	********************/
	if(i_reload >= 0 && ret)
	{
		if(!i_reload)
			i_ask_GT_to_GTT_enable = 1; // Default is enabled

		rc = get_profile_string( ac_PathCfgFile,
								 "IPC",
								 "ASK-GTT-TO-GTTS-ENABLE",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				i_tmp = (short)atoi(ac_value);
				if( i_tmp < 0 ||
					i_tmp > 1 )
				{
					if(!i_reload)
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [IPC][ASK-GTT-TO-GTTS-ENABLE] - Set ENABLED" );
					}
					else
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [IPC][ASK-GTT-TO-GTTS-ENABLE]" );
					}
				}
				else
					i_ask_GT_to_GTT_enable = i_tmp;
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [IPC][ASK-GTT-TO-GTTS-ENABLE] - Set ENABLED" );
				}
				else
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [IPC][ASK-GTT-TO-GTTS-ENABLE]" );
				}
			}
		}
		else
		{
			if(!i_reload)
			{
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [IPC][ASK-GTT-TO-GTTS-ENABLE] - Set ENABLED" );
			}
		}
	}

	if(i_reload >= 0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								"IPC",
								"MTS-TID-SVRC-GTTS",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				wrk_str = strtok( ac_value, ac_delimiters);
				if (wrk_str)
				{
					if ( !(i_taskid_gtt = (short)atoi(wrk_str)) )
					{
						ret = 0;

						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong TaskId [IPC][MTS-TID-SVRC-GTTS]" );
					}
					else
					{
						wrk_str = strtok( NULL, ac_delimiters);
						if (wrk_str)
						{
							if ( !(i_serverclass_gtt = (short)atoi(wrk_str)) )
							{
								ret = 0;

								EVT_manage( EVTN_WRONG_PARAM,
											0,
											0,
											'A',
											"Wrong SrvClass [IPC][MTS-TID-SVRC-GTTS]" );
							}
						}
						else
						{
							ret = 0;

							EVT_manage( EVTN_WRONG_PARAM,
										0,
										0,
										'A',
										"Wrong SrvClass [IPC][MTS-TID-SVRC-GTTS]" );
						}
					}
				}
			}
			else
			{
				ret = 0;

				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [IPC][MTS-TID-SVRC-GTTS]" );
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [IPC][MTS-TID-SVRC-GTTS]" );
		}
	}

	if(i_reload >= 0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								"IPC",
								"MTS-TID-SVRC-MAPOUT",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				wrk_str = strtok( ac_value, ac_delimiters);
				if (wrk_str)
				{
					if ( !(i_taskid_mapout = (short)atoi(wrk_str)) )
					{
						ret = 0;
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong TaskId [IPC][MTS-TID-SVRC-MAPOUT]" );
					}
					else
					{
						wrk_str = strtok( NULL, ac_delimiters);
						if (wrk_str)
						{
							if ( !(i_serverclass_mapout = (short)atoi(wrk_str)) )
							{
								ret = 0;
								EVT_manage( EVTN_WRONG_PARAM,
											0,
											0,
											'A',
											"Wrong SrvClass [IPC][MTS-TID-SVRC-MAPOUT]" );
							}
						}
						else
						{
							ret = 0;
							EVT_manage( EVTN_WRONG_PARAM,
										0,
										0,
										'A',
										"Wrong SrvClass [IPC][MTS-TID-SVRC-MAPOUT]" );
						}
					}
				}
			}
			else
			{
				ret = 0;
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [IPC][MTS-TID-SVRC-MAPOUT]" );
			}
		}
		else
		{
			ret = 0;
			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [IPC][MTS-TID-SVRC-MAPOUT]" );
		}
	}

	/**********************
	** [ROAMING-UNBLUNDING]
	***********************/
	if(i_reload >=0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "ROAMING-UNBLUNDING",
								 "ROMUN-ENABLE",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				i_tmp = 0;
				i_tmp = i_romun_enable;

				i_romun_enable = (short)atoi (ac_value);

				if( i_romun_enable != 0 &&
					i_romun_enable != 1 )
				{
					i_romun_enable = i_tmp;

					EVT_manage( EVTN_WRONG_PARAM,
								0,
								0,
								'A',
								"Wrong [ROAMING-UNBLUNDING][ROMUN-ENABLE]" );
				}

				if( i_romun_enable == 1 )
				{
					rc = get_profile_string( ac_PathCfgFile,
											 "ROAMING-UNBLUNDING",
											 "MAP-PXY-LBO-DPC",
											 &found,
											 ac_value );
					if(!rc)
					{
						if(found)
						{
							l_map_pxy_lbo_dpc = atol(ac_value);

							if(l_map_pxy_lbo_dpc < 0)
							{
								ret 		   = 0;
								i_romun_enable = 0;

								EVT_manage( EVTN_WRONG_PARAM,
											0,
											0,
											'A',
											"Wrong [ROAMING-UNBLUNDING][MAP-PXY-LBO-DPC]" );
							}
						}
						else
						{
							ret 		   = 0;
							i_romun_enable = 0;

							EVT_manage( EVTN_PARAM_MISSING,
										0,
										0,
										'A',
										"Missing [ROAMING-UNBLUNDING][MAP-PXY-LBO-DPC]" );
						}
					}
				}

				if( !i_reload &&
					i_romun_enable == 1 )
				{
					rc = get_profile_string( ac_PathCfgFile,
											"ROAMING-UNBLUNDING",
											"PATH-ARP-DB",
											&found,
											ac_value );
					if(!rc)
					{
						if(found)
						{
							strncpy(ac_path_arp_db,ac_value,sizeof(ac_path_arp_db)-1);
						}
						else
						{
							ret 		   = 0;
							i_romun_enable = 0;

							EVT_manage( EVTN_PARAM_MISSING,
										0,
										0,
										'A',
										"Missing [ROAMING-UNBLUNDING][PATH-ARP-DB]" );
						}
					}
					else
					{
						ret 		   = 0;
						i_romun_enable = 0;

						EVT_manage( EVTN_PARAM_MISSING,
									0,
									0,
									'A',
									"Missing [ROAMING-UNBLUNDING][PATH-ARP-DB]" );
					}
				}
			}
		}
	}

    /*******************
	** [LOG]
	********************/
	if(!i_reload && ret)
	{
		if(!i_reload)
			i_num_days_of_log = 3; // 3 giorni

		rc = get_profile_string( ac_PathCfgFile,
								 "LOG",
								 "PATH-LOG",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				strncpy(ac_path_log_file,ac_value,sizeof(ac_path_log_file)-1);

				rc = get_profile_string( ac_PathCfgFile,
										 "LOG",
										 "NUM-DAYS-OF-LOG",
										 &found,
										 ac_value );
				if(!rc)
				{
					if(found)
					{
						i_tmp = (short)atoi (ac_value);
						if(i_tmp < 0)
						{
							i_num_days_of_log = 3;

							EVT_manage( EVTN_WRONG_PARAM,
										0,
										0,
										'A',
										"Wrong [LOG][NUM-DAYS-OF-LOG] - Set to 3gg" );
						}
						else
							i_num_days_of_log = i_tmp;
					}
					else
					{
						if(!i_reload)
						{
							EVT_manage( EVTN_PARAM_MISSING,
										0,
										0,
										'A',
										"Missing [LOG][NUM-DAYS-OF-LOG] - Set to 3gg" );
						}
					}

					rc = (short)log_init ( ac_path_log_file,
										   ac_my_process_name + 1,
										   i_num_days_of_log );

					if(!rc)
					{
						log_param_filecreate ( 1024 /*filecreate_primary_extent_size*/,
											   1024 /*filecreate_secondary_extent_size*/,
												900 /*filecreate_maximum_extents */ );
					}
				}
				else
				{
					ret = 0;
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [LOG][NUM-DAYS-OF-LOG]" );
				}
			}
			else
			{
				ret = 0;
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [LOG][PATH-LOG]" );
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [LOG][PATH-LOG]" );
		}
	}

	if(i_reload>=0 && ret)
	{
		if(!i_reload)
			i_trace_level = LOG_ERROR;

		rc = get_profile_string( ac_PathCfgFile,
								 "LOG",
								 "TRACE-LEVEL",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				i_tmp = (short)atoi (ac_value);
				if(i_tmp < 0)
				{
					if(!i_reload)
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [LOG][TRACE-LEVEL] - Set to ERROR" );
					}
					else
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [LOG][TRACE-LEVEL]" );
					}
				}
				else
					i_trace_level = i_tmp;
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [LOG][TRACE-LEVEL] - Set to ERROR" );
				}
			}

			if( i_trace_level >= LOG_DEBUG )
			{
				log_param( i_trace_level,
						   LOG_UNBUFFERED,
						   "" );
			}
			else
			{
				log_param( i_trace_level,
						   LOG_STAT,
						   "" );
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [LOG][TRACE-LEVEL]" );
		}
	}

	if(i_reload>=0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "LOG",
								 "TRACE-STRING",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				if(ac_value[0])
					log_set_trace(ac_value);
				else
					log_reset_trace();
			}
		}
	}

	/*******************
	** [STAT]
	********************/
	if(!i_reload && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "STAT",
								 "NBR-MAX-REG",
								 &found,
								 ac_value );

		if(!rc)
		{
			if(found)
			{
				i_stat_max_register=(short)atoi(ac_value);

				rc = get_profile_string( ac_PathCfgFile,
										 "STAT",
										 "GROUP",
										 &found,
										 ac_value );

				if(!rc)
				{
					if(found)
						i_stat_group = (short)atoi(ac_value);
				}
				else
					ret = 0;
			}
			else
			{
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [STAT][NBR-MAX-REG]" );
			}
		}
		else
			ret = 0;
	}

	if(!i_reload && ret)
	{
		i_stat_fw_param_loaded = 0;

		rc = get_profile_string( ac_PathCfgFile,
								 "STAT",
								 "FW-GROUP",
								 &found,
								 ac_value );

		if(!rc)
		{
			if(found)
			{
				i_stat_fw_param_loaded = 1;
				i_localMaxRegs 		   = 100;
				i_stat_fw_group 	   = (short)atoi(ac_value);

				setFWStatRegSet("FW-CALL-PROC    ");
				setFWStatStatsGroup(i_stat_fw_group);
				setFWStatMaxRegs(i_localMaxRegs);
			}
			else
			{
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [STAT][FW-GROUP]" );
			}
		}
	}

	if(i_reload>=0 && ret)
	{
		if(!i_reload)
			l_stat_bump_interval = (long)(5*60); // 5 '

		rc = get_profile_string( ac_PathCfgFile,
								 "STAT",
								 "TIMEOUT-BUMP",
								 &found,
								 ac_value );

		if(!rc)
		{
			if(found)
			{
				l_stat_bump_interval = (long)(atol(ac_value) * 60);
				if(l_stat_bump_interval < 60)
					l_stat_bump_interval = (long)(60*1); // 1'
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [STAT][TIMEOUT-BUMP] - Set to 5'" );
				}
			}
		}
		else
		{
			ret = 0;
		}
	}

	/*******************
	** [DUMP]
	********************/
	if(i_reload >= 0 && ret)
	{
		if(!i_reload)
			i_dump_msg = 0;

		rc = get_profile_string( ac_PathCfgFile,
								"DUMP",
								"DUMP-RAW-MSG-BEFORE-SEND",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				i_dump_msg = (short)atoi(ac_value);

				DumpMsgBeforeSend((char)i_dump_msg);
			}
		}
	}

    return(ret);
} // LoadParameters
