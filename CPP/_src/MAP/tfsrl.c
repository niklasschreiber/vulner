//--------------------------------------------------------------------------------
//   PROJECT : Traffic Steering - Relay Server - v 1.11
//--------------------------------------------------------------------------------
//
//   File Name   : tfsrl.c
//
//   Created     : 01-09-2004
//
//   Last fix	 : 29-11-2004
//                 15-04-2004 Add TCAP_END / TCAP-CONTINUE management: to do relay
//                 07-09-2005 Add EVT manage
//				   25-11-2005 Add VLR CC and MGT external parameters
//				   13-01-2006 Add memory list of VLR GT
//				   03-03-2006 Link with FRAMEWORK $dsmscm.fwaobj
//				   10-04-2006 CPU Request sending request to GTT and TFS Manager
//				   23-05-2007 TCAP-ABORT managed
//							  fixed bug: break in the switch
//				   02-10-2008 Added GT originator control for GPRS Location Update
//				   15-10-2008 Link with FRAMEWORK C and code optimizing
//				   15-02-2010 Added statistic counters idx 89,90,91 and 92
//				   10-06-2010 Bug fix allow VPC
//				   15-03-2011 Added new field c_tcap_map_errorcode into gtt and ts IPC structures
//				   22-03-2011 Added other MAP Error management
//				   01-07-2011 Recompiled for KTSTEA07
//				   28-06-2012 Deployed KTSTEACE ( to be include in KTSTEA08 )
//								- optimized input parameters
//								- Added SSN configuration
//				   30-08-2012 Managed MGT len greater than 16  ( routing SCCP max len 32 - MGT max len 30 )
//							  Relaying msg, internal routing managed: Changes to stop checking if the local point code is available, to overcome erroneous retcode from L_SS7_PC_STATUS
//				   04-09-2012 Added IMSI into ts IPC struct
//				   20-09-2012 Bug Fixed EVT_MANAGER - Fixed the maximum number of events generated by TFS MAP i/f
//													  in a given period of time in order to respect the value
// 													  configured as NBR-ALERT-MSG and/or INTERVAL-ALERT-MSG-TIME parameters
//				   28-11-2012 Bug  Fix: The frames TCAP-CONTINUE,ABORT and END are relayed correctly by RELAY-SERVER
//										necessary to manage the wrong traffic coming from national core network
//				   19-12-2012 Recompiled for A08.01
//				   31-05-2013 Recompiled for A08.02 - due to adding of LTE i/f
//				   10-09-2013 Bug Fixed 3987: - SCCP Calling Party Address Digits Number with length equal to zero
//											  - UDTS Header Decoding Information:
//													the decoding of UDTS messages with Return Cause field
//													size longer than 50 bytes generated a stack overflow
//				   13-09-2013 Recompiled for A08.02  it has been included the bug fix KTSTEACR
//				   02-07-2014 RVU 09.00
//							   - Added Roaming Unbundling management
//				   			   - Added Dual IMSI management: Relaying of LU GSM/GPRS
//								 with Routing Indicator - routing on GT
//				   14-10-2014 Added check MTP3 DPC availability on relaying message towards MAP Pxy or HLR
//				   13-04-2015 KTSTEADD - Added anti steering management for LU GSm/GPrs with SCCP CdPA NPI E.164(GT) instead of E.214 (MGT)
//				   18-11-2015 KTSTEADH - Bug fixing wrong invoke id returned towards vlr/sgsn for steering case
//				   23-03-2016 KTSTEADK - Bug fix ErrCmp SystemFailure Network Resource MAP V3
//				   15-05-2017 KTSTEADQ - HLR on DLA(Down Low Adjust) architecture, FAI(Flexible Allocation of IMSI) activation
//				   29-03-2018 KTSTEADV - Flexible Allocation of IMSI (FAI) - Management of GSM LU/GPRS LU and SCCP CdPA ITU E.164
//
//---------------------------------------------------------------------------------
//
//	Last change  : 29-03-2018
//
//---------------------------------------------------------------------------------
//   Description
//   -----------
//
//---------------------------------------------------------------------------------
//   Functions
//   ------------------
//---------------------------------------------------------------------------------
//---------------------< Include files >-------------------------------------------
#pragma nolist
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <time.h>
#include <ctype.h>
#include <tal.h>
#include <unistd.h>
#include <p2system.p2apdfh>
#include <erainc.ccpy>
#include <cssinc.cext>
#include <cextdecs.h (DELAY,PROCESSHANDLE_GETMINE_,PROCESSHANDLE_DECOMPOSE_,JULIANTIMESTAMP)>
#include <fwlbdf.h>
#include <fwroute.h>
#include <fwdef.h>
#include <fwutlx.h>
#include <fwstatl.h>
#include <sspevt.h>
#include <ssplog.h>
#include <sspfunc.h>
#include <sspstat.h>
#include "gsmdef.h"
#include "tfsrl.h"
#include "tfsipc.h"
#include "tfsdef.h"
#include "tfsdb.h"
#include "tfsfunc.h"
#include "ipcfunc.h"
#include "tfsevt.h"
#include "tfsstat.h"
#pragma list

//---------------------< Definitions >-----------------------------------------

#if (_TNS_E_TARGET)
T0000H06_21JUN2018_KTSTEA10_01() {};
#elif (_TNS_X_TARGET)
T0000L16_21JUN2018_KTSTEA10_01() {};
#endif

//---------------------< Internal Function Prototypes >----------------------
void Process_Initialization( void );

void Msg_print( short i_type);

short LoadParameters( char *ac_PathCfgF,short i_reload );

short Process_Sysmesg_Handler( char *ac_msg );
//---------------------< External Function Prototypes >----------------------
//---------------------< External Variables >--------------------------------
//---------------------< Static and Global Variables >-----------------------
short        	i_shutdown;
short			i_timeout_allow_vpc_set;
VPC_STATUS      vpc_status;
//---------------------------------------------------------------------------
int main( int argc, char **argv )
{
    short				rc;
    short               i_res;
    short               event;
    short               mapversion;
    short               nbrcomps;
    short               outbuflen;
    short               mtype;
    short               i_msg_id;
    short               Stop;
    short               i_allow_all;
    short               i_follow_strategy;
    short               i_fault_mngt_strategy_tmp;
    short               i_sent_r;
    long                l_pc;
    char				c_check_pc;
    char                ac_cd[MAX_INS_STRING_LENGTH +1];
    char                *outbuf = NULL;
    fw_route_infod      routeinfop;     // pointer to routing info
    fw_sel_inparsed     p_sel;          // pointer to SEL parsed elements structure
    transactionId       transaction;
    dialogueStuff       dialogue;
    gtt_data            *gtt;

//    DELAY(1000);

    Stop 					  = 0;
    i_shutdown				  = 0;
    outbuflen 				  = 0;
	i_timeout_allow_vpc_set   = 0;
	i_stat_fw_param_loaded	  = 0;
	i_fault_mngt_strategy_tmp = 0;

	Process_Initialization();

	// Set timer for bump stat
	if( SetTimerBump_(l_stat_bump_interval,TAG_BUMP ))
	{
		EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
					0,
					i_interval_time,
					'A',
					"SIGNALTIMEOUT_() Err. - Bump Stat" );
	}

	if(SIGNALTIMEOUT_( (long)(l_timeout_reload + (long)(30*(long)(JULIANTIMESTAMP(0)%100))),
						0,
						TAG_RELOAD_PARAM ) )
	{
		EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
					0,
					i_interval_time,
					'A',
					"SIGNALTIMEOUT_() Err. - Reload Parameters" );
	}

	// Main Loop
    while ( !Stop )
    {
        rc = FW2_TCAP_Receive ( &event, &mtype,
                                &mapversion, &nbrcomps,
                                &routeinfop, &p_sel,
                                &transaction, &outbuf,
                                &outbuflen, &dialogue );

        if(i_trace_level > LOG_DEBUG)
        {
			log_(LOG_DEBUG2,"%s: FW2_TCAP_Receive : RC[%d] - Buffer len received [%d]",
						__FUNCTION__,
						rc,
						outbuflen);
        }

        if ( rc == FW_RCV_OK )
        {
            switch ( event )
            {
                case FW_RCV_OTHER_MSG:
                {
                	i_msg_id = *(short *)outbuf;

					switch( i_msg_id )
					{
                    	//
                    	// Incoming msg from GTT
                    	//
                        case GTT_TAG:
                        {
                        	if( outbuflen == sizeof(gtt_data) )
                        	{
								i_follow_strategy = 0;
								i_sent_r          = 0;
								l_pc 	   		  = 0;
								c_check_pc 		  = CHECK_PC_AVAILABILITY_ON;

								memset( ac_cd,
										0x00,
										sizeof(ac_cd) );

								//
								// store strategy global variable
								//
								i_fault_mngt_strategy_tmp = i_fault_mngt_strategy;

								vpc_status.i_net_id = GetNetworkID_Default();

								AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_MESG_FROM_GTT);

								log_(LOG_DEBUG2,"%s: RX buffer from GTT - length [%d]",
										__FUNCTION__,
										outbuflen);

								gtt = (gtt_data *)outbuf;

								// MGT called
								memcpy( ac_cd,
										gtt->query_data.address.value,
										gtt->query_data.address.length );

								if( gtt->ResultCode == GTT_RESULT_SUCCESS )
								{
									if( i_mgt_test == 1 )
									{
										if( !memcmp(ac_cd,ac_cd_test,strlen(ac_cd)) )
										{
											i_follow_strategy     = 1; // follow strategy flag
											i_fault_mngt_strategy = 2; // use point code list

											EVT_manage( EVTN_TEST_MGT_OK,
														0,
														0,
														'N',
														"Test: Cd[%s] matches Cd-T[%s]",
														ac_cd,
														ac_cd_test);

											log_(LOG_DEBUG2,"%s: Test: Cd[%s] matches Cd-T[%s]",
													__FUNCTION__,
													ac_cd,
													ac_cd_test);
										}
										else
										{
											i_sent_r = 1; // sent relay flag

											EVT_manage( EVTN_TEST_MGT_KO,
														0,
														0,
														'N',
														"Test: Cd[%s] doesn't match Cd-T[%s]",
														ac_cd,
														ac_cd_test );

											log_(LOG_DEBUG2,"%s: Test: Cd[%s] doesn't match Cd-T[%s]",
													__FUNCTION__,
													ac_cd,
													ac_cd_test);
										}
									}
									else
										i_sent_r = 1;

									if( i_sent_r ) // sent relay if true
									{
										l_pc = 0;

										if( gtt->c_dualimsi_flag == 0x01 ) // Dual IMSI
										{
											if( i_DualImsi_DPC_list_entries )
											{
												vpc_status.i_net_id = GetNetworkID_TSC();

												l_pc = GetDualImsiVDestPC( &vpc_status,
																		   i_DualImsi_DPC_list_entries,
																		   l_DualImsi_pc_list,
																		   i_internal_routing_strategy );

												if( l_pc == -1 )
												{
													l_pc = 0;
													log_(LOG_ERROR,"Dual IMSI DPC unavailable. - Relaying towards HLR");
												}
												else
												{
													c_check_pc = CHECK_PC_AVAILABILITY_OFF;
													log_(LOG_DEBUG,"Getting Dual IMSI DPC[%d]",l_pc);
												}

												vpc_status.i_net_id = GetNetworkID_Default();
											}
											else
											{
												log_(LOG_WARNING,"Dual IMSI MGT checked, but Dual IMSI has not been activated - Default relaying towards HLR");
											}
										}

										if( !l_pc )
										{
											if( gtt->c_E164 == 0x00 ) // E.214
											{
												if( i_FAI_set ) // relay FAI STP
												{
													gtt->query_response.numberingPlan = SPARE;

													vpc_status.i_net_id = GetNetworkID_STP();

													l_pc = GetValidDestPC( &vpc_status,
																		   i_DPC_list_entries,
																		   l_point_code_list,
																		   i_internal_routing_strategy );

													if( l_pc != -1 )
													{
														c_check_pc 	  = CHECK_PC_AVAILABILITY_OFF;

														// flag dualimsi has been reused and overwritten with 0x02 (FAI)
														gtt->c_dualimsi_flag = 0x02;

														log_(LOG_DEBUG,"FAI set - Relaying with DPC[%ld]",l_pc);
													}
													else
													{
														i_shutdown = 0;
														i_sent_r   = 0;

														log_(LOG_DEBUG,"FAI set but No DPC available");
													}

													vpc_status.i_net_id = GetNetworkID_Default();
												}
											}
											else if( gtt->c_E164 == 0x01 ) // E.164
											{
												if( i_E164_set ) // relay to STP - routing on GT+SSN(default 6)
												{
													gtt->query_response.numberingPlan = SPARE;

													vpc_status.i_net_id = GetNetworkID_STP();

													l_pc = GetValidDestPC( &vpc_status,
																		   i_DPC_list_entries,
																		   l_point_code_list,
																		   i_internal_routing_strategy );

													if( l_pc != -1 )
													{
														c_check_pc 	  = CHECK_PC_AVAILABILITY_OFF;

														// flag dualimsi has been reused and overwritten with 0x03 (No FAI but new E.164 routing)
														gtt->c_dualimsi_flag = 0x03;

														log_(LOG_DEBUG,"E.164 set routing on GT+SSN - Relaying with DPC[%ld]",l_pc);
													}
													else
													{
														i_shutdown   = 0;
														i_sent_r 	 = 0;

														log_(LOG_WARNING,"E.164 set routing on GT+SSN has been activated but No DPC available...");
													}

													vpc_status.i_net_id = GetNetworkID_Default();
												}
											}
										}

										if( i_sent_r )
										{
											// relay
											if( ( i_res = Sent_Relay_Msg( &vpc_status,
																		  l_pc,
																		  c_check_pc,
																		  gtt )) )
											{
												AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_RELAY_SENT_KO);

												if( i_res == -1 ||
													i_res == -3 )
												{
													i_shutdown = 1;
												}
											}
											else
											{
												AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_RELAY_SENT_OK);
											}
										}
										else
										{
											AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_RELAY_SENT_KO);
										}
									}
								}
								else
								{
									if( gtt->c_E164 == 0x00 ) // E.214
									{
										if( i_FAI_set ) // relay FAI STP
										{
											i_follow_strategy	  = 1;
											i_fault_mngt_strategy = 2;

											vpc_status.i_net_id = GetNetworkID_STP();

											log_(LOG_DEBUG,"FAI set, force strategy[2] to use DPC List");
										}
										else
										{
											AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_ERROR_FROM_GTT);

											// Error from GTT
											EVT_manage( EVTN_GTT_ERROR_CODE,
														0,
														0,
														'A',
														"Incoming GTT message with Err. Code[%d] - Cd[%s]",
														gtt->ResultCode,
														ac_cd );

											vpc_status.i_net_id = GetNetworkID_Default();
										}
									}
									else if( gtt->c_E164 == 0x01 ) // E.164
									{
										if( i_E164_set ) // relay to STP - routing on GT+SSN(default 6)
										{
											i_follow_strategy	  = 1;
											i_fault_mngt_strategy = 2;

											vpc_status.i_net_id = GetNetworkID_STP();

											log_(LOG_DEBUG,"E.164 set routing on GT+SSN, force strategy[2] to use DPC List");
										}
										else
										{
											AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_ERROR_FROM_GTT);

											// Error from GTT
											EVT_manage( EVTN_GTT_ERROR_CODE,
														0,
														0,
														'A',
														"Incoming GTT message with Err. Code[%d] - Cd[%s]",
														gtt->ResultCode,
														ac_cd );

											vpc_status.i_net_id = GetNetworkID_Default();
										}
									}
								}

								if( i_follow_strategy )
								{
									switch( i_fault_mngt_strategy )
									{
										case 0: //  continue...
										{
											i_shutdown = 0;

											if( (!i_E164_set && gtt->c_E164 == 0x01) || // relay to STP - routing on GT+SSN(default 6)
												(!i_FAI_set && gtt->c_E164 == 0x00) )   // relay FAI STP
											{
												log_(LOG_WARNING,"Incoming GTT message with Err. Code[%d] - Cd[%s:%s] - Fault Strategy set to NO OPERATION TO DO",
														gtt->ResultCode,
														ac_cd,
														(gtt->c_E164 == 0x01?"E.164":"E.214"));
											}

											break;
										}

										case 1: // VPC down
										{
											i_shutdown = 1;

											if( (!i_E164_set && gtt->c_E164 == 0x01) || // relay to STP - routing on GT+SSN(default 6)
												(!i_FAI_set && gtt->c_E164 == 0x00) )   // relay FAI STP
											{
												log_(LOG_WARNING,"Incoming GTT message with Err. Code[%d] - Cd[%s:%s] - Fault Strategy set to VPC down",
														gtt->ResultCode,
														ac_cd,
														(gtt->c_E164 == 0x01?"E.164":"E.214"));
											}

											break;
										}

										case 2: // use point code list
										{
											if( (!i_E164_set && gtt->c_E164 == 0x01) || // relay to STP - routing on GT+SSN(default 6)
												(!i_FAI_set && gtt->c_E164 == 0x00) )   // relay FAI STP
											{
												log_(LOG_WARNING,"Incoming GTT message with Err. Code[%d] - Cd[%s:%s] - Fault Strategy set to use DPC list",
														gtt->ResultCode,
														ac_cd,
														(gtt->c_E164 == 0x01?"E.164":"E.214"));
											}

											// relay STP
											gtt->query_response.numberingPlan = SPARE;

											l_pc = GetValidDestPC( &vpc_status,
																   i_DPC_list_entries,
																   l_point_code_list,
																   i_internal_routing_strategy );

											if( l_pc != -1 )
											{
												c_check_pc = CHECK_PC_AVAILABILITY_OFF;

												if( gtt->c_E164 == 0x00 ) // E.214
												{
													if( i_FAI_set )// relay FAI STP
													{
														// flag dualimsi has been reused and overwritten with 0x02 (FAI)
														gtt->c_dualimsi_flag = 0x02;

														log_(LOG_DEBUG,"FAI set - Relaying with DPC[%ld]",l_pc);
													}
													else
													{
														log_(LOG_WARNING,"GTT Point Code not found - Relaying with DPC[%ld]",l_pc);
													}
												}
												else if( gtt->c_E164 == 0x01 ) // E.164
												{
													if( i_E164_set ) // relay to STP - routing on GT+SSN(default 6)
													{
														// flag dualimsi has been reused and overwritten with 0x03 (No FAI but new E.164 routing)
														gtt->c_dualimsi_flag = 0x03;

														log_(LOG_DEBUG,"E.164 set routing on GT+SSN - Relaying with DPC[%ld]",l_pc);
													}
													else
													{
														log_(LOG_WARNING,"GTT Point Code not found - Relaying with DPC[%ld]",l_pc);
													}
												}
												else
												{
													log_(LOG_WARNING,"GTT Point Code not found - Relaying with DPC[%ld]",l_pc);
												}

												if( (i_res = Sent_Relay_Msg( &vpc_status,
																			 l_pc,
																			 c_check_pc,
																			 gtt )) )
												{
													AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_RELAY_SENT_KO);

													if( i_res == -1 ||
														i_res == -3 )
														i_shutdown = 1;
												}
												else
												{
													AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_RELAY_SENT_OK);
												}
											}
											else
											{
												i_shutdown = 0;
											}

											vpc_status.i_net_id = GetNetworkID_Default();

											break;
										}

										default:
										{
											i_shutdown = 0;

											break;
										}
									}
								}
                        	}
                        	else
                        	{
                        		log_(LOG_ERROR,"%s: RX unexpected buffer len[%d], from GTT Server",
										__FUNCTION__,
										outbuflen);
                        	}

                            break;
                        }

                        default:
                        {
                            AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_UNKNOWN_IPC_MESG_REC);

                            log_(LOG_WARNING,"RX unknown IPC Tag[%d] - Msg discarded",i_msg_id);

                            break;
                        }
                    }

                    break;
                }

                case FW_RCV_COMMAND:
                case FW_RCV_PROCESS_SIGNALTIMEOUT:
                {
                    i_shutdown = 0;
                    Stop = Process_Sysmesg_Handler( outbuf );

                    break;
                }

                case FW_RCV_SHUTDOWN_REQUEST:
                {
                    i_shutdown = 0;
                    Stop 	   = 1;

                    if(i_trace_level > LOG_DEBUG)
                    	log_(LOG_DEBUG2,"%s: RX FW_RCV_SHUTDOWN_REQUEST event",__FUNCTION__);

                    break;
                }

                case FW_RCV_CONTEXT_SIGNALTIMEOUT:
                {
                    i_shutdown = 0;

                    if(i_trace_level > LOG_DEBUG)
                    	log_(LOG_DEBUG2,"%s: RX FW_RCV_CONTEXT_SIGNALTIMEOUT event",__FUNCTION__);

                    break;
                }

                default:
                {
                    AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_UNKNOWN_FW_EVENT_REC);

                    EVT_manage( EVTN_FW_EVENT_UNKNOWN,
								0,
								i_interval_time,
								'A',
								"RX unknown FW event[%d] - Msg Discarded",
								event );

                    log_(LOG_WARNING,"RX unknown FW event[%d] - Msg Discarded",event);

                    break;
                }
            }    // switch (event)

            if( i_shutdown &&
            	(i_internal_routing_strategy == NO_INTERNAL_ROUTING_STRATEGY) &&
            	vpc_status.i_vpc )
			{
				// shutdown TGDS Virtual Point Code
				i_shutdown  = 0;
				i_allow_all = 0;

				vpc_status.i_mode = VPC_DOWN;

				if( !(i_res = VPC_Status( &vpc_status )) )
				{
					AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_SHUTDOWN_PC_REQ_OK);

					EVT_manage( EVTN_PROHIBIT_VPC_OK,
								0,
								0,
								'A',
								"SHUTDOWN VPC[%d] OK",
								vpc_status.i_vpc );

					log_(LOG_WARNING,"SHUTDOWN VPC[%d] OK", vpc_status.i_vpc);

					i_allow_all++;
				}
				else
				{
					if(i_res != P2_SS7_ALREADY_PROHIB)
					{
						AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_SHUTDOWN_PC_REQ_KO);

						EVT_manage( EVTN_PROHIBIT_VPC_KO,
									0,
									0,
									'A',
									"SHUTDOWN VPC[%d] failed - Err.[%d]",
									vpc_status.i_vpc,
									i_res );

						log_(LOG_ERROR,"SHUTDOWN VPC[%d] failed - Err.[%d]",
								vpc_status.i_vpc,
								i_res);
					}
					else
					{
						if( !i_timeout_allow_vpc_set )
						{
							AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_SHUTDOWN_PC_REQ_OK);

							EVT_manage( EVTN_PROHIBIT_VPC_OK,
										0,
										0,
										'A',
										"VPC[%d] already down",
										vpc_status.i_vpc );

							log_(LOG_WARNING,"VPC[%d] already down",vpc_status.i_vpc);
						}

						i_allow_all++;
					}
				}

				if( i_allow_all )
				{
					if( i_auto_allow_vpc && !i_timeout_allow_vpc_set )
					{
						if(!SIGNALTIMEOUT_(l_timeout_allow_vpc,0,TAG_ALLOW_VPC))
							i_timeout_allow_vpc_set = 1;
						else
						{
							EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
										0,
										i_interval_time,
										'A',
										"SIGNALTIMEOUT_() Err. - Allow VPC" );
						}
					}
				}
            }
        }    // if (rc == FW_RCV_OK)
        else
        {
        	EVT_manage( EVTN_FW_ERROR,
						0,
						i_interval_time,
						'A',
						"Err.[%d] - FW2_TCAP_Receive()",
						rc );

            log_(LOG_ERROR,"Err.[%d] - FW2_TCAP_Receive()",rc);
        }
    }

    i_res = (short)BumpStat();
    if( !i_res )
        log_( LOG_INFO, "Bump Statistics" );
    else
    {
    	EVT_manage( EVTN_BUMP_ERROR,
					0,
					0,
					'A',
					"Err.[%d] - BumpStat()",
					i_res );

		log_( LOG_ERROR, "Err.[%d] - BumpStat()",i_res);
    }

    Msg_print( _STOP_ );

    log_close();

    return 0;
}

//
// Manage system message
//
short Process_Sysmesg_Handler( char *ac_msg )
{
    short            i_res;
    short            i_ret = 0;
    short            i_allow_all;
    long			 i_tmp_reload_param;
    IO_SYS_TIMEOUT   *signal;
    SYS_COMMAND      *cmd;

    signal = (IO_SYS_TIMEOUT *)ac_msg;

    switch( signal->id )
    {
        case SYS_MSG_TIME_TIMEOUT:
        {
			log_(LOG_DEBUG2,"%s: [SYS_MSG_TIME_TIMEOUT] - Sock[%d] Tag[%ld]",
					__FUNCTION__,
					signal->i_socket,
					signal->l_tag);

			switch ( signal->l_tag )
			{
                case TAG_RELOAD_PARAM:
                {
					if (checkChgFile( ac_filecfg_oss ))
					{
						if( !LoadParameters(ac_filecfg,RELOAD) )
						{
							EVT_manage( EVTN_PARAM_MISSING,
										0,
										i_interval_time,
										'A',
										"Missing parameter or fileini opened" );

							log_ (LOG_WARNING, "Reloading parameters failed: missing parameter or fileini opened");
						}
						else
						{
							log_ (LOG_DEBUG2, "%s: Reloading parameters successfully",__FUNCTION__);
						}
					}
					else
					{
						log_ (LOG_DEBUG2, "%s: Reloading parameters not necessary",__FUNCTION__);
					}

					if(SIGNALTIMEOUT_( (long)(l_timeout_reload + (long)(30*(long)(JULIANTIMESTAMP(0)%100))),
										0,
										TAG_RELOAD_PARAM ) )
					{
						EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
									0,
									i_interval_time,
									'A',
									"SIGNALTIMEOUT_(() Err. - Reload Parameters" );
					}

                    break;
                }

                case TAG_BUMP:
				{
					// Bump
					i_res = (short)BumpStat();

					if( !i_res )
					{
						log_( LOG_DEBUG2, "%s: Bump Statistics",__FUNCTION__ );
					}
					else
					{
						EVT_manage( EVTN_BUMP_ERROR,
									0,
									i_interval_time,
									'A',
									"Err.[%d] - BumpStat()",
									i_res );

						log_(LOG_ERROR, "Err.[%d] - BumpStat()",i_res);
					}

					if( SetTimerBump_(l_stat_bump_interval,TAG_BUMP ))
					{
						EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
									0,
									i_interval_time,
									'A',
									"SIGNALTIMEOUT_() Err. - BumpStat()" );
					}

					break;
				}

                case TAG_ALLOW_VPC:
				{
					i_shutdown  			= 0;
					i_allow_all 			= 0;
					i_timeout_allow_vpc_set = 0;

					vpc_status.i_mode = VPC_UP;

					if( !(i_res = VPC_Status( &vpc_status )) )
					{
						AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_ALLOW_PC_REQ_OK);

						EVT_manage( EVTN_ALLOW_VPC_OK,
									0,
									i_interval_time,
									'A',
									"VPC[%d] is alive",
									vpc_status.i_vpc );

						log_(LOG_DEBUG2,"%s: VPC[%d] is alive",__FUNCTION__, vpc_status.i_vpc);

						i_allow_all++;
					}
					else
					{
						if(i_res == P2_SS7_ALREADY_ALLOWD)
						{
							AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_ALLOW_PC_REQ_OK);

							EVT_manage( EVTN_ALLOW_VPC_OK,
										0,
										i_interval_time,
										'A',
										"VPC[%d] is already alive",
										vpc_status.i_vpc );

							log_(LOG_DEBUG2,"%s: VPC[%d] is already alive",__FUNCTION__, vpc_status.i_vpc);

							i_allow_all++;
						}
						else
						{
							AddStat(STAT_MAPIRO_PREFIX_REGS,"MAPRL",TOT_ALLOW_PC_REQ_KO);

							EVT_manage( EVTN_ALLOW_VPC_OK,
										0,
										i_interval_time,
										'A',
										"Allow VPC[%d] failed - Err.[%d] - Retry",
										 vpc_status.i_vpc,
										 i_res );

							log_(LOG_ERROR,"VPC[%d] is down - Err.[%d] - Retry",
										vpc_status.i_vpc,
										i_res);
						}
					}

					if( i_allow_all )
					{
						if( i_auto_allow_vpc )
						{
							if(!SIGNALTIMEOUT_(l_timeout_allow_vpc,0,TAG_ALLOW_VPC))
								i_timeout_allow_vpc_set = 1;
							else
							{
								EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
											0,
											i_interval_time,
											'A',
											"SIGNALTIMEOUT_() Err. - Allow VPC" );
							}
						}
					}

					break;
                }
            }

            break;
        }

        case SYS_MSG_COMMAND:
		{
			cmd = (SYS_COMMAND *)ac_msg;
			cmd->ac_cmd[cmd->i_cnt]=0;

			if( !strcmp(cmd->ac_cmd,"PARAMREFRESH") )
			{
				log_(LOG_DEBUG2,"%s: - RX PARAMREFRESH request",__FUNCTION__);

				i_tmp_reload_param = (long)(JULIANTIMESTAMP(0)%100);

				if( i_tmp_reload_param < 3 )
					i_tmp_reload_param = 3;

				// shifting JULIANTIMESTAMP(0) + [3 - 33"]
				if( SIGNALTIMEOUT_((long)( 30 * i_tmp_reload_param ),0,TAG_RELOAD_PARAM) )
				{
					EVT_manage( EVTN_SIGNALTIMEOUT_ERROR,
								0,
								0,
								'A',
								"SIGNALTIMEOUT_() Err. - PARAMREFRESH" );

					log_(LOG_ERROR,"SIGNALTIMEOUT_() Err. - Reloading parameters" );
				}
				else
				{
					EVT_manage( EVTN_CMD_REFRESH_PARAM_OK,
								0,
								0,
								'N',
								"PARAMREFRESH request recv." );
				}
			}
			else
			{
				EVT_manage( EVTN_CMD_UNHANDLE,
							0,
							0,
							'A',
							"RX unhandle cmd[%s] request",
							cmd->ac_cmd );

				log_(LOG_ERROR,"RX unhandle cmd[%s] request",cmd->ac_cmd);
			}

			break;
		}

        case SYS_MSG_STOP_1:
        case SYS_MSG_STOP_2:
        {
            i_ret = 1;

            break;
        }
    }

    return i_ret;

} // End Of Procedure

// print start/stop message on log_
void Msg_print( short i_type )
{
    log_ (LOG_INFO, "**************************");
    log_ (LOG_INFO, "***                    ***");
    log_ (LOG_INFO, "***  Traffic Steering  ***");
    log_ (LOG_INFO, "***      MAP-RELAY     ***");
    log_ (LOG_INFO, "***                    ***");
    log_ (LOG_INFO, "***       V 1.11       ***");
    log_ (LOG_INFO, "***                    ***");

    switch( i_type )
    {
        case _START_:
        {
        	EVT_manage( EVTN_START,
						0,
						0,
						'N',
						"[%s] started",
						ac_my_process_name );

            log_ (LOG_INFO, "***      Started       ***");

            break;
        }

        case _STOP_:
        {
        	EVT_manage( EVTN_STOP,
						0,
						0,
						'N',
						"[%s] stopped by user",
						ac_my_process_name );

            log_ (LOG_INFO, "***      Stopped       ***");

            break;
        }
    }

    log_ (LOG_INFO, "***                    ***");
    log_ (LOG_INFO, "**************************");
}

/****************************************************************************
***  Module Name:  Process_Initialization                                  **
***                                                                        **
***  Description:  This module is responsible for processing all of the    **
***                run-time parameters and determining if the process      **
***                has been started under the Node or in a stand-alone     **
***                environment.                                            **
*****************************************************************************/
void Process_Initialization (void)
{
    short           rc;
    short           i_proch[20];
    short           i_maxlen = sizeof (ac_my_process_name);
    char            *wrk_str;
    FW_ACTabled     AC_List;

    if ((wrk_str = getenv ("FILEINI")) != NULL)
    {
        memset(ac_filecfg,0x00, sizeof(ac_filecfg));
		memset(ac_my_process_name,0x00, sizeof(ac_my_process_name));
        strncpy(ac_filecfg,wrk_str,sizeof(ac_filecfg)-1);

        PROCESSHANDLE_GETMINE_ (i_proch);
        PROCESSHANDLE_DECOMPOSE_ ( i_proch,&i_my_cpu,
                                   ,,,,,
                                   ac_my_process_name,
                                   i_maxlen,
                                   &i_maxlen, );

		setChgFile(ac_filecfg,ac_filecfg_oss);

        if(!LoadParameters(ac_filecfg,LOAD))
        {
        	exit(-1);
        }
        else
        {
            Msg_print( _START_ );

            // Initialize FWR
			AC_List.ac_array_entries = 0;
			rc = TCAP_InitializeFramework( &AC_List );

			if( rc != FW_IF_OK &&
				rc != FW_IF_NoOperation )
			{
				EVT_manage( EVTN_FW_INITIALIZE_KO,
							0,
							0,
							'A',
							"FW initialization failure - Err.[%d] - Exit",
							rc );

				log_(LOG_ERROR,"TCAP_InitializeFramework() failure - Exit" );

				exit(-1);
			}

			L_INITIALIZE_END();
			
			if(!Stat_init( "",
						   "",
						   "",
						   i_stat_group,
						   i_stat_max_register,
						   S_MAX_IDX_NUMBER ))
			{
				EVT_manage( EVTN_STAT_NOT_INIT,
							0,
							0,
							'A',
							"Stat_init failure - Exit" );

				log_(LOG_ERROR,"Stat_init failure - Exit");

				exit(-1);
			}
			else
			{
				log_(LOG_INFO,"Network-Name[%s] - NI[TFS(%d)|STP(%d)|TSC(%d)] - TFS Int.Routing[%s] - TFS VPC[%d] - FAI[%s] - FAI SSN[%d] - E.164 GT+SSN[%s]",
							vpc_status.ac_net_name,
							GetNetworkID_Default(),
							GetNetworkID_STP(),
							GetNetworkID_TSC(),
							(i_internal_routing_strategy?"INTERNAL ROUTING SET":"NOT INTERNAL ROUTING SET"),
							vpc_status.i_vpc,
							(i_FAI_set?"FAI SET":"FAI UNSET"),
							(i_FAI_set?i_FAI_SSN:-1),
							(i_E164_set?"ON":"OFF"));

				setFW_networkId((char)GetNetworkID_Default());

				if(i_stat_fw_param_loaded)
				{
					if( (rc = (short)FW_StatOpen_No_Bump()) ) // Open FW stat without BUMP_STAT functionality
					{
						EVT_manage( EVTN_STAT_NOT_INIT,
									0,
									0,
									'A',
									"Initialize FW Stats failure - Err.[%d]",
									rc);


						log_(LOG_ERROR,"Initialize FW Stats failure - Err.[%d]", rc);
					}
					else
						log_(LOG_INFO,"TFS FW Stat_init successfully - FW Group[%d]", i_stat_fw_group);
				}
			}
        }
    }
    else
        exit(-1);
} // End Of Procedure: Process_Initialization

//
// Load parameters function. Load INI file
//
short LoadParameters( char *ac_PathCfgFile,
                      short i_reload )
{
    short	rc      = 0;
    short   ret     = 1;
    short	i_tmp;
    short   i;
    int     found   = 0;
    char    ac_value[255];
    char    *wrk_str;
    char    *ac_delimiters=",;-:";

    memset(&vpc_status,0x00, sizeof(VPC_STATUS));

    SetDefaultSSN( HLR ); // SSN=6 Default

    /*******************
	** [EVT]
	********************/
	if( !i_reload )
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "EVT",
								 "SSID-OWNER",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				strncpy(ac_cSSID_Owner,ac_value,sizeof(ac_cSSID_Owner)-1);

				rc = get_profile_string( ac_PathCfgFile,
										 "EVT",
										 "SSID-NUMBER",
										 &found,
										 ac_value );
				if(!rc)
				{
					if(found)
					{
						i_nSSID_Number = (short)atoi(ac_value);

						rc = get_profile_string( ac_PathCfgFile,
												 "EVT",
												 "SSID-VERSION",
												 &found,
												 ac_value );
						if(!rc)
						{
							if(found)
							{
								strncpy(ac_cSSID_Version,ac_value,sizeof(ac_cSSID_Version)-1);

								//
								//  initialize EVT on $0
								//
								if (!sspevt_init( "TFS-RL", ac_cSSID_Owner, i_nSSID_Number, ac_cSSID_Version ) )
									EVT_manage_init();
								else
									ret = 0;
							}
							else
								ret = 0;
						}
						else
							ret = 0;
					}
					else
						ret = 0;
				}
				else
					ret = 0;
			}
			else
				ret = 0;
		}
		else
			ret = 0;
	}

	if(i_reload >= 0 && ret)
	{
		if(!i_reload)
			i_nbr_alert_msg = 1; // Default value 1 msg

		rc = get_profile_string( ac_PathCfgFile,
								 "EVT",
								 "NBR-ALERT-MSG",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				i_tmp = (short)atoi(ac_value);
				if(i_tmp < 0)
				{
					if(!i_reload)
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [EVT][NBR-ALERT-MSG] - Set to 1 msg" );
					}
					else
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [EVT][NBR-ALERT-MSG]" );
					}
				}
				else
					i_nbr_alert_msg = i_tmp;
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [EVT][NBR-ALERT-MSG] - Set to 1 msg" );
				}
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [EVT][NBR-ALERT-MSG]" );
		}
	}

	if(i_reload >= 0 && ret)
	{
		if(!i_reload)
			i_interval_time = 300; // Default value in seconds 300"

		rc = get_profile_string( ac_PathCfgFile,
								 "EVT",
								 "INTERVAL-ALERT-MSG-TIME",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				i_tmp = (short)atoi(ac_value);
				if(i_tmp < 0)
				{
					if(!i_reload)
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [EVT][INTERVAL-ALERT-MSG-TIME] - Set to 5'" );
					}
					else
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [EVT][INTERVAL-ALERT-MSG-TIME]" );
					}
				}
				else
					i_interval_time = i_tmp;
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [EVT][INTERVAL-ALERT-MSG-TIME] - Set to 5'" );
				}
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [EVT][INTERVAL-ALERT-MSG-TIME]" );
		}
	}

    /*******************
    ** [COMMON]
    ********************/
	if(i_reload >= 0 && ret)
	{
		if(!i_reload)
			l_timeout_reload = (long)(15*60*100); // 15'

		rc = get_profile_string( ac_PathCfgFile,
								"COMMON",
								"TIMEOUT-RELOAD-PARAM",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				l_timeout_reload= (long)(atol(ac_value)*60*100);
				if(l_timeout_reload < 6000)
				{
					l_timeout_reload = 6000;

					EVT_manage( EVTN_WRONG_PARAM,
								0,
								0,
								'A',
								"Wrong [COMMON][TIMEOUT-RELOAD-PARAM] - Set to 1'" );
				}
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [COMMON][TIMEOUT-RELOAD-PARAM] - Set to 15'" );
				}
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [COMMON][TIMEOUT-RELOAD-PARAM]" );
		}
	}

    if(i_reload >= 0 && ret)
    {
    	if(!i_reload)
    		i_mgt_test = 0; // default value

        rc = get_profile_string( ac_PathCfgFile,
                                "COMMON",
                                "MGT-TEST-CONTROL",
                                &found,
                                ac_value );
        if(!rc)
        {
            if(found)
            {
                i_tmp = (short)atoi(ac_value);
                if( i_tmp < 0 ||
                	i_tmp > 1 )
                {
                	if(!i_reload)
                	{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [COMMON][MGT-TEST-CONTROL] - 0 or 1" );
                	}
                	else
                	{
                		EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [COMMON][MGT-TEST-CONTROL]" );
                	}
                }
                else
                {
                	i_mgt_test = i_tmp;

                    rc = get_profile_string( ac_PathCfgFile,
                                            "COMMON",
                                            "MGT-TEST",
                                            &found,
                                            ac_value );
                    if(!rc)
                    {
                        if(found)
                            strncpy(ac_cd_test,ac_value,sizeof(ac_cd_test)-1);
                        else
                            i_mgt_test = 0;
                    }
                    else
                        i_mgt_test = 0;
                }
            }
        }
    }

    /*******************
    ** [PC]
    ********************/
    if(i_reload >= 0 && ret)
    {
    	if(!i_reload)
    		i_fault_mngt_strategy = 0; // default continue

        rc = get_profile_string( ac_PathCfgFile,
                                "PC",
                                "FAULT-MNGT-STRATEGY",
                                &found,
                                ac_value );
        if(!rc)
        {
            if(found)
            {
                i_tmp = (short)atoi(ac_value);
                if( i_tmp < 0 ||
                	i_tmp > 2 )
                {
                	if(!i_reload)
                	{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][FAULT-MNGT-STRATEGY] - Set to 0" );
                	}
                	else
                	{
                		EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][FAULT-MNGT-STRATEGY] ");
                	}
                }
                else
                	i_fault_mngt_strategy = i_tmp;
            }
            else
            {
            	if(!i_reload)
            	{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [PC][FAULT-MNGT-STRATEGY] - Set to 0");
            	}
            	else
            	{
            		EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [PC][FAULT-MNGT-STRATEGY]" );
            	}
            }
        }
        else
        {
            ret = 0;

            EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][FAULT-MNGT-STRATEGY]");
        }
    }

    if(i_reload >= 0 && ret)
	{
    	i_DualImsi_DPC_list_entries = 0;

		rc = get_profile_string( ac_PathCfgFile,
								"PC",
								"TSC-PC-LIST",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				strncpy(ac_pc_list,ac_value,sizeof(ac_pc_list)-1);

				memset ( (char *)&l_DualImsi_pc_list[0],
						 NULL,
						 sizeof(long));

				for (i=0; i < DPC_LIST_MAX_SIZE; i++)
				{
					if ( !i )
						wrk_str = strtok(ac_pc_list, ac_delimiters);
					else
						wrk_str = strtok(NULL , ac_delimiters);

					if ( !wrk_str )
						break;

					l_DualImsi_pc_list[i] = (long)atol(wrk_str);
				}

				if( !i )
				{
					ret = 0;
					EVT_manage( EVTN_WRONG_PARAM,
								0,
								0,
								'A',
								"Wrong [PC][TSC-PC-LIST] - No DPC set");
				}
				else
					i_DualImsi_DPC_list_entries = (short) i;
			}
		}
	}

    if(i_reload >= 0 && ret)
    {
        rc = get_profile_string( ac_PathCfgFile,
                                "PC",
                                "POINT-CODE-LIST",
                                &found,
                                ac_value );
        if(!rc)
        {
            if(found)
            {
                i_DPC_list_entries = 0;
                strncpy(ac_pc_list,ac_value,sizeof(ac_pc_list)-1);

                memset ( (char *)&l_point_code_list[0],
                         NULL,
                         sizeof(long));

                for (i=0; i < DPC_LIST_MAX_SIZE; i++)
                {
                    if ( !i )
                        wrk_str = strtok(ac_pc_list, ac_delimiters);
                    else
                        wrk_str = strtok(NULL , ac_delimiters);

                    if ( !wrk_str )
                        break;

                    l_point_code_list[i] = (long)atol(wrk_str);
                }

                if( !i )
                {
                	ret = 0;

                	EVT_manage( EVTN_WRONG_PARAM,
								0,
								0,
								'A',
								"Wrong [PC][POINT-CODE-LIST] - No PC set");
                }
                else
                {
                	i_DPC_list_entries = (short) i;

                	i_FAI_set = 0; // default not set

					rc = get_profile_string( ac_PathCfgFile,
											 "PC",
											 "FAI-SET",
											 &found,
											 ac_value );
					if(!rc)
					{
						if(found)
						{
							i_FAI_set = (short)atoi(ac_value);

							switch( i_FAI_set )
							{
								case 0:
								{
									// FAI Unset
									break;
								}

								case 1:
								{
									// ok
									rc = get_profile_string( ac_PathCfgFile,
															 "PC",
															 "FAI-SSN",
															 &found,
															 ac_value );
									if(!rc)
									{
										if(found)
										{
											i_FAI_SSN = (short)atoi(ac_value);
											SetFAI_SSN(i_FAI_SSN);
										}
										else
										{
											i_FAI_set = 0; // default not set

											EVT_manage( EVTN_PARAM_MISSING,
														0,
														0,
														'A',
														"Missing [PC][FAI-SSN] - FAI unset");
										}
									}
									else
									{
										i_FAI_set = 0; // default not set

										EVT_manage( EVTN_PARAM_MISSING,
													0,
													0,
													'A',
													"Missing [PC][FAI-SSN] - FAI unset");
									}

									break;
								}

								default:
								{
									i_FAI_set = 0; // default not set

									EVT_manage( EVTN_WRONG_PARAM,
												0,
												0,
												'A',
												"Wrong [PC][FAI-SET] - FAI unset");

									break;
								}
							}
						}
						else
						{
							i_FAI_set = 0; // default not set

							EVT_manage( EVTN_WRONG_PARAM,
										0,
										0,
										'A',
										"Wrong [PC][FAI-SET] - FAI unset");
						}
					}

					rc = get_profile_string( ac_PathCfgFile,
											 "PC",
											 "ROUTING-E164-GT-SSN",
											 &found,
											 ac_value );
					if(!rc)
					{
						if(found)
						{
							i_E164_set = (short)atoi(ac_value);

							switch( i_E164_set )
							{
								case 0:
								case 1:
								{
									break;
								}

								default:
								{
									i_E164_set = 0; // default not set

									EVT_manage( EVTN_WRONG_PARAM,
												0,
												0,
												'A',
												"Wrong [PC][ROUTING-E164-GT-SSN] - ROUTING-E164-GT-SSN unset");

									break;
								}
							}
						}
						else
						{
							i_E164_set = 0; // default not set

							EVT_manage( EVTN_WRONG_PARAM,
										0,
										0,
										'A',
										"Wrong [PC][ROUTING-E164-GT-SSN] - ROUTING-E164-GT-SSN unset");
						}
					}
                }
            }
            else
            {
            	ret = 0;

            	EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PC][POINT-CODE-LIST]");
            }
        }
        else
        {
            ret = 0;

            EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][POINT-CODE-LIST]");
        }
    }

    if(i_reload >= 0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								"PC",
								"TFS-NET-NAME",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				strncpy(vpc_status.ac_net_name,ac_value,sizeof(vpc_status.ac_net_name)-1);
			}
			else
			{
				ret = 0;

				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PC][TFS-NET-NAME]" );
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][TFS-NET-NAME]" );
		}
	}

	if(i_reload >= 0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "PC",
								 "TFS-NET-ID",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				vpc_status.i_net_id = (unsigned short)atoi(ac_value);
				SetNetworkID_Default(vpc_status.i_net_id);
			}
			else
			{
				ret = 0;

				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PC][TFS-NET-ID]" );
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][TFS-NET-ID]" );
		}
	}

	if(i_reload >= 0 && ret)
	{
		SetNetworkID_TSC(vpc_status.i_net_id); // default
		SetNetworkID_STP(vpc_status.i_net_id); // default

		rc = get_profile_string( ac_PathCfgFile,
								 "PC",
								 "TSC-NET-ID",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				SetNetworkID_TSC((short)atoi(ac_value));
			}
		}

		if(i_reload >= 0 && ret)
		{
			rc = get_profile_string( ac_PathCfgFile,
									 "PC",
									 "STP-NET-ID",
									 &found,
									 ac_value );
			if(!rc)
			{
				if(found)
				{
					SetNetworkID_STP((short)atoi(ac_value));
				}
			}
		}
	}

	if(i_reload >= 0 && ret)
	{
		// To cause the INS Router to send a message with “Route on Global Title” set in the SCCP’s called party address to an adjacent node (e.g. STP),
		// the application must send to some DPC that is NOT one of the local point codes.
		// A MTP3 Routing Label DPC value of zero results in correct routing of messages out of the INS to one of the nodes identified in the INS document “Configuration Planning Guide”.

		if(!i_reload)
			i_internal_routing_strategy = NO_INTERNAL_ROUTING_STRATEGY; // Default NO_INTERNAL_ROUTING_STRATEGY

		rc = get_profile_string( ac_PathCfgFile,
								 "PC",
								 "TFS-INTERNAL-ROUTING-STRATEGY",
								 &found,
								 ac_value );

		if(!rc)
		{
			if(found)
			{
				i_tmp = (short)atoi(ac_value);

				if( i_tmp < 0 ||
					i_tmp > 1 )
				{
					if(!i_reload)
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][TFS-INTERNAL-ROUTING-STRATEGY] - Set to 0" );
					}
					else
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][TFS-INTERNAL-ROUTING-STRATEGY] - 0 or 1" );
					}
				}
				else
					i_internal_routing_strategy = i_tmp;
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [PC][TFS-INTERNAL-ROUTING-STRATEGY] - Set to 0" );
				}
			}
		}
		else
		{
			if(!i_reload)
			{
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PC][TFS-INTERNAL-ROUTING-STRATEGY] - Set to 0" );
			}
		}
	}

	if(i_reload >= 0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "PC",
								 "TFS-VPC",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				if(i_internal_routing_strategy == INTERNAL_ROUTING_STRATEGY)
					vpc_status.i_vpc = 0; // forced to 0
				else
					vpc_status.i_vpc = (short)atoi(ac_value);
			}
			else
			{
				ret = 0;

				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [PC][TFS-VPC]" );
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][TFS-VPC]" );
		}
	}

    if(i_reload >= 0 && ret)
    {
    	if(!i_reload)
    		i_auto_allow_vpc = 0;

        rc = get_profile_string( ac_PathCfgFile,
                                 "PC",
                                 "AUTO-ALLOW-VPC",
                                 &found,
                                 ac_value );
        if(!rc)
        {
            if(found)
            {
                i_tmp = (short)atoi(ac_value);
                if( i_tmp < 0 ||
                	i_tmp > 1 )
                {
                	if(!i_reload)
                	{
                		EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][AUTO-ALLOW-VPC] - Set to 0" );
                	}
                	else
                	{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][AUTO-ALLOW-VPC] - 0 or 1" );
                	}
                }
                else
                	i_auto_allow_vpc = i_tmp;
            }
            else
            {
            	if(!i_reload)
            	{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [PC][AUTO-ALLOW-VPC] - Set to 0" );
            	}
            }
        }
        else
        {
        	ret = 0;

        	EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][AUTO-ALLOW-VPC]" );
        }
    }

    if(i_reload >= 0 && ret)
    {
    	if(!i_reload)
    		l_timeout_allow_vpc = (long)(5*60*100); // 5'

        rc = get_profile_string( ac_PathCfgFile,
                                "PC",
                                "VPC-ALLOW-TIMEOUT",
                                &found,
                                ac_value );
        if(!rc)
        {
            if(found)
            {
            	l_timeout_allow_vpc = (long)(atol(ac_value)*60*100);
                if( l_timeout_allow_vpc < 0 )
                {
                	if(!i_reload)
                	{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][VPC-ALLOW-TIMEOUT] - Set to 5'" );
                	}
                	else
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [PC][VPC-ALLOW-TIMEOUT]" );
					}
                }
            }
            else
            {
            	if(!i_reload)
            	{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [PC][VPC-ALLOW-TIMEOUT] - Set to 5'" );
            	}
            }
        }
        else
        {
            ret = 0;

            EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [PC][VPC-ALLOW-TIMEOUT]" );
        }
    }

    /*******************
	** [PC]
	********************/
	if(i_reload >= 0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "PC",
								 "HLR-SSN",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				i_hlr_ssn = (short)atoi(ac_value);
				if(i_hlr_ssn > 0)
					SetDefaultSSN( i_hlr_ssn );
			}
		}
	}

    /*******************
	** [LOG]
	********************/
	if(!i_reload && ret)
	{
		if(!i_reload)
			i_num_days_of_log = 3; // 3 giorni

		rc = get_profile_string( ac_PathCfgFile,
								 "LOG",
								 "PATH-LOG",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				strncpy(ac_path_log_file,ac_value,sizeof(ac_path_log_file)-1);

				rc = get_profile_string( ac_PathCfgFile,
										 "LOG",
										 "NUM-DAYS-OF-LOG",
										 &found,
										 ac_value );
				if(!rc)
				{
					if(found)
					{
						i_tmp = (short)atoi (ac_value);
						if(i_tmp < 0)
						{
							i_num_days_of_log = 3;

							EVT_manage( EVTN_WRONG_PARAM,
										0,
										0,
										'A',
										"Wrong [LOG][NUM-DAYS-OF-LOG] - Set to 3gg" );
						}
						else
							i_num_days_of_log = i_tmp;
					}
					else
					{
						if(!i_reload)
						{
							EVT_manage( EVTN_PARAM_MISSING,
										0,
										0,
										'A',
										"Missing [LOG][NUM-DAYS-OF-LOG] - Set to 3gg" );
						}
					}

					rc = (short)log_init ( ac_path_log_file,
										   ac_my_process_name + 1,
										   i_num_days_of_log );

					if(!rc)
					{
						log_param_filecreate ( 1024 /*filecreate_primary_extent_size*/,
											   1024 /*filecreate_secondary_extent_size*/,
												900 /*filecreate_maximum_extents */ );
					}
				}
				else
				{
					ret = 0;
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [LOG][NUM-DAYS-OF-LOG]" );
				}
			}
			else
			{
				ret = 0;
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [LOG][PATH-LOG]" );
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [LOG][PATH-LOG]" );
		}
	}

	if(i_reload>=0 && ret)
	{
		if(!i_reload)
			i_trace_level = LOG_ERROR;

		rc = get_profile_string( ac_PathCfgFile,
								 "LOG",
								 "TRACE-LEVEL",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				i_tmp = (short)atoi (ac_value);
				if(i_tmp < 0)
				{
					if(!i_reload)
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [LOG][TRACE-LEVEL] - Set to ERROR" );
					}
					else
					{
						EVT_manage( EVTN_WRONG_PARAM,
									0,
									0,
									'A',
									"Wrong [LOG][TRACE-LEVEL]" );
					}
				}
				else
					i_trace_level = i_tmp;
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [LOG][TRACE-LEVEL] - Set to ERROR" );
				}
			}

			if( i_trace_level >= LOG_DEBUG )
			{
				log_param( i_trace_level,
						   LOG_UNBUFFERED,
						   "" );
			}
			else
			{
				log_param( i_trace_level,
						   LOG_STAT,
						   "" );
			}
		}
		else
		{
			ret = 0;

			EVT_manage( EVTN_PARAM_MISSING,
						0,
						0,
						'A',
						"Missing [LOG][TRACE-LEVEL]" );
		}
	}

	if(i_reload>=0 && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "LOG",
								 "TRACE-STRING",
								 &found,
								 ac_value );
		if(!rc)
		{
			if(found)
			{
				if(ac_value[0])
					log_set_trace(ac_value);
				else
					log_reset_trace();
			}
		}
	}

	/*******************
	** [STAT]
	********************/
	if(!i_reload && ret)
	{
		rc = get_profile_string( ac_PathCfgFile,
								 "STAT",
								 "NBR-MAX-REG",
								 &found,
								 ac_value );

		if(!rc)
		{
			if(found)
			{
				i_stat_max_register=(short)atoi(ac_value);

				rc = get_profile_string( ac_PathCfgFile,
										 "STAT",
										 "GROUP",
										 &found,
										 ac_value );

				if(!rc)
				{
					if(found)
						i_stat_group = (short)atoi(ac_value);
				}
				else
					ret = 0;
			}
			else
			{
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [STAT][NBR-MAX-REG]" );
			}
		}
		else
			ret = 0;
	}

	if(!i_reload && ret)
	{
		i_stat_fw_param_loaded = 0;

		rc = get_profile_string( ac_PathCfgFile,
								 "STAT",
								 "FW-GROUP",
								 &found,
								 ac_value );

		if(!rc)
		{
			if(found)
			{
				i_stat_fw_param_loaded = 1;
				i_localMaxRegs 		   = 100;
				i_stat_fw_group 	   = (short)atoi(ac_value);

				setFWStatRegSet("FW-CALL-PROC    ");
				setFWStatStatsGroup(i_stat_fw_group);
				setFWStatMaxRegs(i_localMaxRegs);
			}
			else
			{
				EVT_manage( EVTN_PARAM_MISSING,
							0,
							0,
							'A',
							"Missing [STAT][FW-GROUP]" );
			}
		}
	}

	if(i_reload>=0 && ret)
	{
		if(!i_reload)
			l_stat_bump_interval = (long)(5*60); // 5 '

		rc = get_profile_string( ac_PathCfgFile,
								 "STAT",
								 "TIMEOUT-BUMP",
								 &found,
								 ac_value );

		if(!rc)
		{
			if(found)
			{
				l_stat_bump_interval = (long)(atol(ac_value) * 60);
				if(l_stat_bump_interval < 60)
					l_stat_bump_interval = (long)(60*1); // 1'
			}
			else
			{
				if(!i_reload)
				{
					EVT_manage( EVTN_PARAM_MISSING,
								0,
								0,
								'A',
								"Missing [STAT][TIMEOUT-BUMP] - Set to 5'" );
				}
			}
		}
		else
		{
			ret = 0;
		}
	}

	/*******************
	** [DUMP]
	********************/
	if(i_reload >= 0 && ret)
	{
		if(!i_reload)
			i_dump_msg = 0;

		rc = get_profile_string( ac_PathCfgFile,
								"DUMP",
								"DUMP-RAW-MSG-BEFORE-SEND",
								&found,
								ac_value );
		if(!rc)
		{
			if(found)
			{
				i_dump_msg = (short)atoi(ac_value);

				DumpMsgBeforeSend((char)i_dump_msg);
			}
		}
	}


	return(ret);
} // LoadParameters
